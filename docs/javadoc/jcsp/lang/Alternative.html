<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_162) on Wed Apr 25 09:57:43 BST 2018 -->
<title>Alternative (jcsp alpha-1.1.2 API)</title>
<meta name="date" content="2018-04-25">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Alternative (jcsp alpha-1.1.2 API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../jcsp/lang/AlternativeError.html" title="class in jcsp.lang"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?jcsp/lang/Alternative.html" target="_top">Frames</a></li>
<li><a href="Alternative.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">jcsp.lang</div>
<h2 title="Class Alternative" class="title">Class Alternative</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>jcsp.lang.Alternative</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="typeNameLabel">Alternative</span>
extends java.lang.Object</pre>
<div class="block">This enables a process to wait passively for and choose
 between a number of <a href="../../jcsp/lang/Guard.html" title="class in jcsp.lang"><code>Guard</code></a> events.
 <P>
 <A HREF="#constructor_summary">Shortcut to the Constructor and Method Summaries.</A>
 <H2>Description</H2>
 The <code>Alternative</code> class enables a <code>CSProcess</code> to wait passively for and
 choose between a number of <a href="../../jcsp/lang/Guard.html" title="class in jcsp.lang"><code>Guard</code></a> events.  This is known as
 <code>ALT</code><I>ing</I>.
 <P>
 <I>Note: for those familiar with the <I><B>occam</B></I> multiprocessing
 language, this gives the semantics of the </I><code>ALT</code><I> and
 </I><code>PRI</code> <code>ALT</code><I> constructs, extended with a built-in implementation
 of the classical </I><code>FAIR</code> <code>ALT</code><I>.</I>
 <P>
 The <code>Alternative</code> constructor takes an array of guards.  Processes
 that need to <I>Alt</I> over more than one set of guards will need a separate
 <code>Alternative</code> instance for each set.
 <P>
 Eight types of <code>Guard</code> are provided in <code>jcsp.lang</code>:
 <UL>
   <LI>
      <a href="../../jcsp/lang/AltingChannelInput.html" title="class in jcsp.lang"><code>AltingChannelInput</code></a>: <I>object channel input</I> --
      ready if unread data is pending in the channel.
   <LI>
      <a href="../../jcsp/lang/AltingChannelInputInt.html" title="class in jcsp.lang"><code>AltingChannelInputInt</code></a>: <I>integer channel input</I> --
      ready if unread data is pending in the channel.
   <LI>
      <a href="../../jcsp/lang/AltingChannelOutput.html" title="class in jcsp.lang"><code>AltingChannelOutput</code></a>: <I>object channel output</I> --
      ready if a reading process can take the offered data
      (<a href="../../jcsp/lang/One2OneChannelSymmetric.html" title="interface in jcsp.lang"><code><i>symmetric</i></code></a> channels only).
   <LI>
      <a href="../../jcsp/lang/AltingChannelOutputInt.html" title="class in jcsp.lang"><code>AltingChannelOutputInt</code></a>: <I>integer channel output</I> --
      ready if a reading process can take the offered data
      (<a href="../../jcsp/lang/One2OneChannelSymmetricInt.html" title="interface in jcsp.lang"><code><i>symmetric</i></code></a> channels only).
   <LI>
      <a href="../../jcsp/lang/AltingChannelAccept.html" title="class in jcsp.lang"><code>AltingChannelAccept</code></a>: <I>CALL accept</I> --
      ready if an unaccepted call is pending.
   <LI>
      <a href="../../jcsp/lang/AltingBarrier.html" title="class in jcsp.lang"><code>AltingBarrier</code></a>: <I>barrier synchronisation</I> --
      ready if all enrolled processes are offering to synchronise.
   <LI>
      <a href="../../jcsp/lang/CSTimer.html" title="class in jcsp.lang"><code>CSTimer</code></a>: <I>timeout</I> --
      ready if the timeout has expired (timeout
      values are absolute time values, not delays)
   <LI>
      <a href="../../jcsp/lang/Skip.html" title="class in jcsp.lang"><code>Skip</code></a>: <I>skip</I> --
      always ready.
 </UL>
 <P>
 By invoking one of the following methods, a process may passively wait for
 one or more of the guards associated with an <code>Alternative</code> object
 to become ready.  The methods differ in the way they choose which guard
 to select in the case when two or more guards are ready:
 <UL>
   <LI>
      <a href="../../jcsp/lang/Alternative.html#select--"><code><code>select</code></code></a> waits for one or more of the guards
      to become ready.  If more than one become ready, it makes an
      <I>arbitrary</I> choice between them (and corresponds to the
      <I><B>occam</B></I> <code>ALT</code>).
   <LI>
      <a href="../../jcsp/lang/Alternative.html#priSelect--"><code><code>priSelect</code></code></a> also waits for one or more of
      the guards to become ready.  However, if more than one becomes ready,
      it chooses the <I>first</I> one listed (and corresponds to the
      <I><B>occam</B></I> <code>PRI</code> <code>ALT</code>).  Note: the use of
      <code>priSelect</code> between channel inputs and a skip guard (at lowest
      priority) gives us a <I>polling</I> operation on the <I>readiness</I>
      of those channels.</I>
   <LI>
      <a href="../../jcsp/lang/Alternative.html#fairSelect--"><code><code>fairSelect</code></code></a> also waits for one or more
      of the guards to become ready.  If more than one become ready, it
      prioritises its choice so that the guard it chose <I>the last time
      it was invoked</I> has lowest priority this time.  This corresponds
      to a common <I><B>occam</B></I> idiom used for real-time applications.
      If <code>fairSelect</code> is used
      in a loop, a ready guard has the guarantee that no other guard will be
      serviced <I>twice</I> before it will be serviced.  This enables
      an upper bound on service times to be calculated and ensures that no
      ready guard can be indefinitely starved.
 </UL>
 <P>
 Finally, each guard may be <A HREF="Alternative.html#Wot-no-Chickens">
 <I>pre-conditioned</I></A> with a run-time test
 to decide if it should be considered in the current choice.  This allows
 considerable flexibilty -- for example, we can decide whether timeouts
 shoud be set, channels refused or polling enabled depending
 on the run-time state of the <I>Alting</I> process.
 </P>
 <H2>Examples</H2>
 <H3>A Fair Multiplexor</H3>
 This example demonstrates a process that <I>fairly</I> multiplexes traffic
 from its array of input channels to its single output channel.  No input
 channel will be starved, regardless of the eagerness of its competitors.
 <PRE>
 import jcsp.lang.*;
 <I></I>
 public class FairPlex implements CSProcess {
 <I></I>
   private final AltingChannelInput[] in;
   private final ChannelOutput out;
 <I></I>
   public FairPlex (final AltingChannelInput[] in, final ChannelOutput out) {
     this.in = in;
     this.out = out;
   }
 <I></I>
   public void run () {
 <I></I>
     final Alternative alt = new Alternative (in);
 <I></I>
     while (true) {
       final int index = alt.fairSelect ();
       out.write (in[index].read ());
     }
 <I></I>
   }
 <I></I>
 }
 </PRE>
 Note that if <code>priSelect</code> were used above, higher-indexed channels would be
 starved if lower-indexed channels were continually demanding service.
 If <code>select</code> were used, no starvation analysis is possible.
 The <code>select</code> mechanism should only be used when starvation is not an issue.
 
 <H3><A NAME="FairMuxTime">A Fair Multiplexor with a Timeout and Poisoning</H3>
 This example demonstrates a process that <I>fairly</I> multiplexes traffic
 from its input channels to its single output channel, but which timeouts
 after a user-settable time.  Whilst running, no input channel
 will be starved, regardless of the eagerness of its competitors.
 The process also illustrates the poisoning of channels, following the timeout.
 <PRE>
 import jcsp.lang.*;
 
 public class FairPlexTime implements CSProcess {
 
   private final AltingChannelInput[] in;
   private final ChannelOutput out;
   private final long timeout;
 
   public FairPlexTime (final AltingChannelInput[] in, final ChannelOutput out,
                        final long timeout) {
     this.in = in;
     this.out = out;
     this.timeout = timeout;
   }
 
   public void run () {
 
     final Guard[] guards = new Guard[in.length + 1];
     System.arraycopy (in, 0, guards, 0, in.length);
 
     final CSTimer tim = new CSTimer ();
     final int timerIndex = in.length;
     guards[timerIndex] = tim;
 
     final Alternative alt = new Alternative (guards);
 
     boolean running = true;
     tim.setAlarm (tim.read () + timeout);
     while (running) {
       final int index = alt.fairSelect ();
       if (index == timerIndex) {
         running = false;
       } else {
         out.write (in[index].read ());
       }
     }
     System.out.println ("\n\r\tFairPlexTime: timed out ... poisoning all channels ...");
     for (int i = 0; i &lt; in.length; i++) {
       in[i].poison (42);                       // assume: channel immunity &lt; 42
     }
     out.poison (42);                           // assume: channel immunity &lt; 42
 
   }
 
 }
 </PRE>
 Note that if <code>priSelect</code> were used above, higher-indexed guards would be
 starved if lower-indexed guards were continually demanding service -- and
 the timeout would never be noticed.
 If <code>select</code> were used, no starvation analysis is possible.
 <P>
 Sometimes we need to use <code>priSelect</code> to impose a <I>specific</I>
 (as opposed to <I>fair</I>) choice that overcomes the external scheduling of events.
 For example, if we were concerned that the timeout above should
 be responded to <I>immediately</I> and unconcerned about the fair servicing of its
 channels, we should put its <code>CSTimer</code> as the first element of its <code>Guard</code>
 array and use <code>priSelect</code>.
 <P>
 To demonstrate <code>FairPlexTime</code>, consider:
 <PRE>
 import jcsp.lang.*;
 import jcsp.plugNplay.*;
 
 class FairPlexTimeTest {
 
   public static void main (String[] args) {
 
     final One2OneChannel[] a = Channel.one2OneArray (5, 0);     // poisonable channels (zero immunity)
     final One2OneChannel b = Channel.one2One (0);               // poisonable channels (zero immunity)

     final long timeout = 5000;                                  // 5 seconds
 
     new Parallel (
       new CSProcess[] {
         new Generate (a[0].out (), 0),
         new Generate (a[1].out (), 1),
         new Generate (a[2].out (), 2),
         new Generate (a[3].out (), 3),
         new Generate (a[4].out (), 4),
         new FairPlexTime (Channel.getInputArray (a), b.out (), timeout),
         new Printer (b.in (), "FairPlexTimeTest ==> ", "\n")
       }
     ).run ();
 
   }
 
 }
 </PRE>
 where <a href="../../jcsp/plugNplay/Generate.html" title="class in jcsp.plugNplay"><code>Generate</code></a> sends its given <tt>Integer</tt> down its output channel
 as often as it can.
 This results in continuous demands on <tt>FairPlexTime</tt> by all its clients
 and demonstrates its fair servicing of those demands.
 <P>
 The <a href="../../jcsp/plugNplay/Generate.html" title="class in jcsp.plugNplay"><code>Generate</code></a> and <a href="../../jcsp/plugNplay/Printer.html" title="class in jcsp.plugNplay"><code>Printer</code></a> are
 programmed to deal with being poisoned.
 Here is the <tt>run()</tt> method for <tt>Generate</tt>:
 <PRE>
 public void run() {
   try {
     while (true) {
       out.write (N);
     }
   } catch (PoisonException p) {
     // the 'out' channel must have been posioned ... nothing left to do!
   }
 }
 </PRE>
 In general, there will be things to do &ndash; especially if there is more
 than one channel.
 For example, here is the <tt>catch</tt> block at the end of the <tt>run()</tt>
 method for <a href="../../jcsp/plugNplay/Delta.html" title="class in jcsp.plugNplay"><code>Delta</code></a> (which has a single input channel-end,
 <tt>in</tt>, and an array of output channel-ends, <tt>out</tt>):
 <PRE>
   } catch (PoisonException p) {
     // don't know which channel was posioned ... so, poison them all!
     int strength = p.getStrength ();   // use same strength of poison
     in.poison (strength);
     for  (int i = 0; i &lt; out.length; i++) {
       out[i].poison (strength);
     }
   }
 </PRE>

 <H3><A NAME="STFR">A Simple Traffic Flow Regulator</H3>
 The <code>Regulate</code> process controls the rate of flow of traffic from its input
 to output channels.  It produces a constant rate of output flow, regardless of
 the rate of its input.  At the end of each timeslice defined by the required output
 rate, it outputs the last object input during that timeslice.  If nothing has come
 in during a timeslice, the previous output will be repeated (note: this will be a
 <code>null</code> if nothing has ever arrived).  If the input flow is greater than
 the required output flow, data will be discarded.
 <P>
 The interval (in msecs) defining the output flow rate is given by a constructor argument.
 This can be changed at any time by sending a new interval (as a <code>Long</code>)
 down the <code>reset</code> channel.
 <P>
 <I> Note: this example shows how simple it is to program time-regulated functionality
 like that performed by </I><code>java.awt.Component.repaint</code><I>.</I>
 <PRE>

//////////////////////////////////////////////////////////////////////
//                                                                  //
//  JCSP ("CSP for Java") Libraries                                 //
//  Copyright (C) 1996-2018 Peter Welch, Paul Austin and Neil Brown //
//                2001-2004 Quickstone Technologies Limited         //
//                2005-2018 Kevin Chalmers                          //
//                                                                  //
//  You may use this work under the terms of either                 //
//  1. The Apache License, Version 2.0                              //
//  2. or (at your option), the GNU Lesser General Public License,  //
//       version 2.1 or greater.                                    //
//                                                                  //
//  Full licence texts are included in the LICENCE file with        //
//  this library.                                                   //
//                                                                  //
//  Author contacts: P.H.Welch@kent.ac.uk K.Chalmers@napier.ac.uk   //
//                                                                  //
//////////////////////////////////////////////////////////////////////

package jcsp.plugNplay;

 import jcsp.lang.*;
 
 public class Regulate implements CSProcess {
 
   private final AltingChannelInput in, reset;
   private final ChannelOutput out;
   private final long initialInterval;
 
   public Regulate (final AltingChannelInput in, final AltingChannelInput reset,
                    final ChannelOutput out, final long initialInterval) {
     this.in = in;
     this.reset = reset;
     this.out = out;
     this.initialInterval = initialInterval;
   }
 
   public void run () {
 
     final CSTimer tim = new CSTimer ();
 
     final Guard[] guards = {reset, tim, in};              // prioritised order
     final int RESET = 0;                                  // index into guards
     final int TIM = 1;                                    // index into guards
     final int IN = 2;                                     // index into guards
 
     final Alternative alt = new Alternative (guards);
 
     Object x = null;                                      // holding object
 
     long interval = initialInterval;
 
     long timeout = tim.read () + interval;
     tim.setAlarm (timeout);
 
     while (true) {
       switch (alt.priSelect ()) {
         case RESET:
           interval = ((Long) reset.read ()).longValue ();
           timeout = tim.read ();                          // fall through
         case TIM:
           out.write (x);
           timeout += interval;
           tim.setAlarm (timeout);
         break;
         case IN:
           x = in.read ();
         break;
       }
     }
 
   }
 
 }
 </PRE>
 <P>
 To demonstrate <code>Regulate</code>, consider:
 <PRE>
 class RegulateTest {
 
   public static void main (String[] args) {
 
     final One2OneChannel a = Channel.one2One ();
     final One2OneChannel b = Channel.one2One ();
     final One2OneChannel c = Channel.one2One ();
 
     final One2OneChannel reset = Channel.one2one (new OverWriteOldestBuffer (1));
 
     new Parallel (
       new CSProcess[] {
         new Numbers (a.out ()),                               // generate numbers
         new FixedDelay (250, a.in (), b.out ()),              // let them through every quarter second
         new Regulate (b.in (), reset.in (), c.out (), 1000),  // initially sample every second
         new CSProcess () {
           public void run () {
             Long[] sample = {new Long (1000), new Long (250), new Long (100)};
             int[] count = {10, 40, 100};
             while (true) {
               for (int cycle = 0; cycle < sample.length; cycle++) {
                 reset.write (sample[cycle]);
                 System.out.println ("\nSampling every " + sample[cycle] + " ms ...\n");
                 for (int i = 0; i < count[cycle]; i++) {
                   Integer n = (Integer) c.read ();
                   System.out.println ("\t==> " + n);
                 }
               }
             }
           }
         }
       }
     ).run ();
   }
 
 }
 </PRE>
 The reader may like to consider the danger of deadlock in the above system if
 the <code>reset</code> channel were not an <I>overwriting</I> one.

 <A NAME="Polling">
 <H3>Polling</H3>
 Sometimes, we want to handle incoming channel data if it's there, but get on with
 something else if all is quiet.  This can be done by <code>PRI</code> <code>ALT</code><I>ing</I>
 the channels we wish to poll against a <code>SKIP</code> guard:
 <PRE>
 import jcsp.lang.*;
 
 public class Polling implements CSProcess {
 
   private final AltingChannelInput in0;
   private final AltingChannelInput in1;
   private final AltingChannelInput in2;
   private final ChannelOutput out;
 
   public Polling (final AltingChannelInput in0, final AltingChannelInput in1,
                   final AltingChannelInput in2, final ChannelOutput out) {
     this.in0 = in0;
     this.in1 = in1;
     this.in2 = in2;
     this.out = out;
   }
 
   public void run() {
 
     final Skip skip = new Skip ();
     final Guard[] guards = {in0, in1, in2, skip};
     final Alternative alt = new Alternative (guards);
 
     while (true) {
       switch (alt.priSelect ()) {
         case 0:
           ...  process data pending on channel in0 ...
         break;
         case 1:
           ...  process data pending on channel in1 ...
         break;
         case 2:
           ...  process data pending on channel in2 ...
         break;
         case 3:
           ...  nothing available for the above ...
           ...  so get on with something else for a while ...
           ...  then loop around and poll again ...
         break;
       }
     }
 
   }
 
 }
 </PRE>
 The above technique lets us poll <I>any</I> <a href="../../jcsp/lang/Guard.html" title="class in jcsp.lang"><code>Guard</code></a> events, including
 timeouts.  If we just want to poll <I>channels</I> for input events, see
 the <a href="../../jcsp/lang/AltingChannelInput.html#pending--"><code>pending</code></a> methods of the various
 ``<TT>...2One...</TT>'' channels for a more direct and efficient way.
 <P>
 <I>Note: polling is an often overused technique.  Make sure your design would
 not be better suited with a blocking ALT and with the `something else' done by
 a process running in parallel.</I>

 <A NAME="Wot-no-Chickens">
 <H3>The <A HREF="http://wotug.org/parallel/groups/wotug/java/discussion/">`Wot-no-Chickens?'</A> Canteen</H3>
 This examples demonstrates the use of <I>pre-conditions</I> on the <code>ALT</code>
 guards.  The <code>Canteen</code> process buffers a supply of chickens.  It can
 hold a maximum of 20 chickens.  Chickens are supplied on the <code>supply</code>
 line in batches of, at most, 4.  Chickens are requested by hungry philosophers
 who share the <code>request</code> line to the <code>Canteen</code>.  In response to
 such requests, one chicken is delivered down the <code>deliver</code> line.
 <P>
 The <code>Canteen</code> refuses further supplies if it has no room for the maximum
 (4) batch supply.  The <code>Canteen</code> refuses requests from the philosophers
 if it has no chickens.
 <PRE>
 import jcsp.lang.*;
 
 public class Canteen implements CSProcess {
 
   private final AltingChannelInput supply;    // from the cook
   private final AltingChannelInput request;   // from a philosopher
   private final ChannelOutput deliver;        // to a philosopher
 
   public Canteen (final AltingChannelInput supply,
                   final AltingChannelInput request,
                   final ChannelOutput deliver) {
     this.supply = supply;
     this.request = request;
     this.deliver = deliver;
   }
 
   public void run() {
 
     final Guard[] guard = {supply, request};
     final boolean[] preCondition = new boolean[guard.length];
     final int SUPPLY = 0;
     final int REQUEST = 1;
 
     final Alternative alt = new Alternative (guard);
 
     final int maxChickens = 20;
     final int maxSupply = 4;
     final int limitChickens = maxChickens - maxSupply;
 
     final Integer oneChicken = new Integer (1);
     // ready to go!
 
     int nChickens = 0;
     // invariant : 0 <= nChickens <= maxChickens
 
     while (true) {
       preCondition[SUPPLY] = (nChickens <= limitChickens);
       preCondition[REQUEST] = (nChickens > 0);
       switch (alt.priSelect (preCondition)) {
         case SUPPLY:
           nChickens += ((Integer) supply.read ()).intValue ();  // <= maxSupply
         break;
         case REQUEST:
           Object dummy = request.read ();
           // we have to still input the signal
           deliver.write (oneChicken);
           // preCondition ==> (nChickens > 0)
           nChickens--;
         break;
       }
     }
 
   }
 
 }
 </PRE>
 <P>
 Contrast the above programming of the canteen as a CSP <I>process</I> rather
 than a <I>monitor</I>.  A monitor cannot refuse a callback when noone has the lock,
 even though it may not be in a state to process it.  In the above, a <code>supply</code>
 <I>method</I> would have to cope with its being called when there is no room to take the supply.
 A <code>request</code> <I>method</I> would have to be dealt with even though there may be no chickens
 to deliver.  Monitors manage such problems by putting their callers on hold
 (<code>wait</code>), but that means that their methods have to rely on each other to get
 out of any resulting embarassment (using <code>notify</code>).
 And that means that the logic of those methods has to be tightly coupled, which
 makes reasoning about them hard.  This gets worse the more interdependent methods
 the monitor has.
 <P>
 On the other hand, the above <code>Canteen</code> <I>process</I> simply refuses service on
 its <code>supply</code> and <code>request</code> <I>channels</I> if it can't cope, leaving
 the supplying or requesting processes waiting harmlessly on those channels.
 The service responses can assume their run-time set <I>pre-conditions</I> and have
 independent -- and trivial -- logic.  When circumstances permit,
 the blocked processes are serviced in the normal way.
 </P>
 <H2>Implementation Footnote</H2>
 This <code>Alternative</code> class and the various channel classes
 (e.g. <a href="../../jcsp/lang/One2OneChannel.html" title="interface in jcsp.lang"><code>One2OneChannel</code></a>) are mutually dependent monitors -- they see instances
 of each other and invoke each others' strongly interdependent methods.  This logic
 is inspired by the published algorithms and data structures burnt into the microcode
 of the <I>transputer</I> some 15 years ago (1984).  Getting this logic <I>`right'</I>
 in the context of Java monitors is something we have done <code>(n + 1)</code> times,
 only to find it flawed <code>n</code> times with an unsuspected race-hazard months
 (sometimes years) later.  Hopefully, we have it <I>right</I> now ... but a proof
 of correctness is really needed!
 </P>
 To this end, a formal (CSP) model of Java's monitor primitives
 (the <code>synchronized</code> keyword and the <code>wait</code>, <code>notify</code> and
 <code>notifyAll</code> methods of the <code>Object</code> class) has been built.
 This has been used for the <I>formal verification</I> of the JCSP implementation
 of channel <code>read</code> and <code>write</code>, along with the correctness of
 <I>2-way</I> channel input <code>Alternative</code>s.
 Details and references are listed under
 <A HREF="http://www.cs.kent.ac.uk/projects/ofa/jcsp/index.html#Model"><I>`A CSP Model
 for Java Threads'</I> on the JCSP web-site</A>.
 [The proof uses the <A HREF="http://www.formal.demon.co.uk/FDR2.html">FDR</A>
 model checker.  Model checkers do not easily allow verification of results containing
 free variables - such as the correctness of the <I>n-way</I> <code>Alternative</code>.
 An investigation of this using <I>formal transformation</I> of one system of CSP equations
 into another, rather than <I>model checking</I> is being considered.]
 <P>
 The <I>transputer</I> designers always said that getting its microcoded scheduler
 logic right was one of their hardest tasks.  Working directly with the monitor
 concept means working at a similar level of difficulty for application programs.
 One of the goals of JCSP is to protect users from ever having to work at that level,
 providing instead a range of CSP primitives whose ease of use scales well with
 application complexity -- and in whose implementation those monitor complexities
 are correctly distilled and hidden.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../jcsp/lang/Guard.html" title="class in jcsp.lang"><code>Guard</code></a>, 
<a href="../../jcsp/lang/AltingChannelInput.html" title="class in jcsp.lang"><code>AltingChannelInput</code></a>, 
<a href="../../jcsp/lang/AltingChannelInputInt.html" title="class in jcsp.lang"><code>AltingChannelInputInt</code></a>, 
<a href="../../jcsp/lang/AltingChannelAccept.html" title="class in jcsp.lang"><code>AltingChannelAccept</code></a>, 
<a href="../../jcsp/lang/AltingBarrier.html" title="class in jcsp.lang"><code>AltingBarrier</code></a>, 
<a href="../../jcsp/lang/CSTimer.html" title="class in jcsp.lang"><code>CSTimer</code></a>, 
<a href="../../jcsp/lang/Skip.html" title="class in jcsp.lang"><code>Skip</code></a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected java.lang.Object</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/Alternative.html#altMonitor">altMonitor</a></span></code>
<div class="block">The monitor synchronising the writers and alting reader</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../jcsp/lang/Alternative.html#Alternative-jcsp.lang.Guard:A-">Alternative</a></span>(<a href="../../jcsp/lang/Guard.html" title="class in jcsp.lang">Guard</a>[]&nbsp;guard)</code>
<div class="block">Construct an <code>Alternative</code> object operating on the <a href="../../jcsp/lang/Guard.html" title="class in jcsp.lang"><code>Guard</code></a>
 array of events.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/Alternative.html#fairSelect--">fairSelect</a></span>()</code>
<div class="block">Returns the index of one of the ready guards.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/Alternative.html#fairSelect-boolean:A-">fairSelect</a></span>(boolean[]&nbsp;preCondition)</code>
<div class="block">Returns the index of one of the ready guards whose <code>preCondition</code> index
 is true.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/Alternative.html#priSelect--">priSelect</a></span>()</code>
<div class="block">Returns the index of one of the ready guards.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/Alternative.html#priSelect-boolean:A-">priSelect</a></span>(boolean[]&nbsp;preCondition)</code>
<div class="block">Returns the index of one of the ready guards whose <code>preCondition</code>
 index is true.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/Alternative.html#select--">select</a></span>()</code>
<div class="block">Returns the index of one of the ready guards.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/Alternative.html#select-boolean:A-">select</a></span>(boolean[]&nbsp;preCondition)</code>
<div class="block">Returns the index of one of the ready guards whose <code>preCondition</code>
 index is true.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="altMonitor">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>altMonitor</h4>
<pre>protected&nbsp;java.lang.Object altMonitor</pre>
<div class="block">The monitor synchronising the writers and alting reader</div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Alternative-jcsp.lang.Guard:A-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Alternative</h4>
<pre>public&nbsp;Alternative(<a href="../../jcsp/lang/Guard.html" title="class in jcsp.lang">Guard</a>[]&nbsp;guard)</pre>
<div class="block">Construct an <code>Alternative</code> object operating on the <a href="../../jcsp/lang/Guard.html" title="class in jcsp.lang"><code>Guard</code></a>
 array of events.  Supported guard events are channel inputs
 (<a href="../../jcsp/lang/AltingChannelInput.html" title="class in jcsp.lang"><code>AltingChannelInput</code></a> and <a href="../../jcsp/lang/AltingChannelInputInt.html" title="class in jcsp.lang"><code>AltingChannelInputInt</code></a>),
 CALL channel accepts (<a href="../../jcsp/lang/AltingChannelAccept.html" title="class in jcsp.lang"><code>AltingChannelAccept</code></a>),
 barriers (<a href="../../jcsp/lang/AltingBarrier.html" title="class in jcsp.lang"><code>AltingBarrier</code></a>),
 timeouts (<a href="../../jcsp/lang/CSTimer.html" title="class in jcsp.lang"><code>CSTimer</code></a>) and skips (<a href="../../jcsp/lang/Skip.html" title="class in jcsp.lang"><code>Skip</code></a>).
 <P></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>guard</code> - the event guards over which the select operations will be made.</dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="select--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>select</h4>
<pre>public final&nbsp;int&nbsp;select()</pre>
<div class="block">Returns the index of one of the ready guards. The method will block
 until one of the guards becomes ready.  If more than one is ready,
 an <I>arbitrary</I> choice is made.</div>
</li>
</ul>
<a name="priSelect--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>priSelect</h4>
<pre>public final&nbsp;int&nbsp;priSelect()</pre>
<div class="block">Returns the index of one of the ready guards. The method will block
 until one of the guards becomes ready.  If more than one is ready,
 the one with the lowest index is selected.</div>
</li>
</ul>
<a name="fairSelect--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fairSelect</h4>
<pre>public final&nbsp;int&nbsp;fairSelect()</pre>
<div class="block">Returns the index of one of the ready guards. The method will block
 until one of the guards becomes ready.  Consequetive invocations will
 service the guards `fairly' in the case when many guards are always
 ready.  <I>Implementation note: the last guard serviced has the lowest
 priority next time around.</I></div>
</li>
</ul>
<a name="select-boolean:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>select</h4>
<pre>public final&nbsp;int&nbsp;select(boolean[]&nbsp;preCondition)</pre>
<div class="block">Returns the index of one of the ready guards whose <code>preCondition</code>
 index is true. The method will block until one of these guards becomes
 ready.  If more than one is ready, an <I>arbitrary</I> choice is made.
 <P>
 <I>Note: the length of the </I><code>preCondition</code><I> array must be the
 same as that of the array of guards with which this object was constructed.</I>
 <P></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>preCondition</code> - the guards from which to select</dd>
</dl>
</li>
</ul>
<a name="priSelect-boolean:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>priSelect</h4>
<pre>public final&nbsp;int&nbsp;priSelect(boolean[]&nbsp;preCondition)</pre>
<div class="block">Returns the index of one of the ready guards whose <code>preCondition</code>
 index is true. The method will block until one of these guards becomes
 ready.  If more than one is ready, the one with the lowest index is selected.
 <P>
 <I>Note: the length of the </I><code>preCondition</code><I> array must be the
 same as that of the array of guards with which this object was constructed.</I>
 <P></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>preCondition</code> - the guards from which to select</dd>
</dl>
</li>
</ul>
<a name="fairSelect-boolean:A-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>fairSelect</h4>
<pre>public final&nbsp;int&nbsp;fairSelect(boolean[]&nbsp;preCondition)</pre>
<div class="block">Returns the index of one of the ready guards whose <code>preCondition</code> index
 is true. The method will block until one of these guards becomes ready.
 Consequetive invocations will service the guards `fairly' in the case
 when many guards are always ready.  <I>Implementation note: the last
 guard serviced has the lowest priority next time around.</I>
 <P>
 <I>Note: the length of the </I><code>preCondition</code><I> array must be the
 same as that of the array of guards with which this object was constructed.</I>
 <P></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>preCondition</code> - the guards from which to select</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../jcsp/lang/AlternativeError.html" title="class in jcsp.lang"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?jcsp/lang/Alternative.html" target="_top">Frames</a></li>
<li><a href="Alternative.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
