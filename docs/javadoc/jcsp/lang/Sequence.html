<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_162) on Wed Apr 25 09:57:44 BST 2018 -->
<title>Sequence (jcsp alpha-1.1.2 API)</title>
<meta name="date" content="2018-04-25">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Sequence (jcsp alpha-1.1.2 API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../jcsp/lang/RejectableOne2OneChannel.html" title="class in jcsp.lang"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../jcsp/lang/SharedAltingConnectionClient.html" title="class in jcsp.lang"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?jcsp/lang/Sequence.html" target="_top">Frames</a></li>
<li><a href="Sequence.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">jcsp.lang</div>
<h2 title="Class Sequence" class="title">Class Sequence</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>jcsp.lang.Sequence</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><a href="../../jcsp/lang/CSProcess.html" title="interface in jcsp.lang">CSProcess</a></dd>
</dl>
<hr>
<br>
<pre>public class <span class="typeNameLabel">Sequence</span>
extends java.lang.Object
implements <a href="../../jcsp/lang/CSProcess.html" title="interface in jcsp.lang">CSProcess</a></pre>
<div class="block">This constructor taks an array of <TT>CSProcess</TT>es
 and returns a <TT>CSProcess</TT> that is the sequential composition of
 its process arguments.
 <P>
 <A HREF="#constructor_summary">Shortcut to the Constructor and Method Summaries.</A>
 <H2>Description</H2>
 The <TT>Sequence</TT> constructor taks an array of <TT>CSProcess</TT>es
 and returns a <TT>CSProcess</TT> that is
 the sequential composition of its process arguments.
 <P>
 <I>Note: for those familiar with the <I><B>occam</B></I> programming
 language, the <TT>Sequence</TT> class gives the semantics of the
 <TT>SEQ</TT> construct.</I>
 <P>
 This class is included for completeness.  Sequential code is normally
 be handled by sequential Java code.  If we need to run some
 <TT>CSProcess</TT>es in sequence, we can just execute their <TT>run</TT>
 methods in sequence.  However, using this <TT>Sequence</TT> class
 lets us switch between sequential and parallel composition of processes
 with a single word change (replace <TT>Sequence</TT> by <TT>Parallel</TT>)
 in our code.  For some applications (e.g. the example below), this may provide
 a useful comparison.
 <P>
 <TT>CSProcess</TT>es can be added to a <TT>Sequence</TT> object either via the
 <a href="../../jcsp/lang/Sequence.html#Sequence-jcsp.lang.CSProcess:A-"><code>constructor</code></a> or the <a href="../../jcsp/lang/Sequence.html#addProcess-jcsp.lang.CSProcess-"><code><TT>addProcess</TT></code></a>
 methods.  If a call to <TT>addProcess</TT> is made while the
 <TT>run</TT> method is executing, the extra process(es) will not be
 executed until the next time <TT>run</TT> is invoked.
 <P>
 <TT>CSProcess</TT>es can be removed from <TT>Sequence</TT> object via
 the <a href="../../jcsp/lang/Sequence.html#removeProcess-jcsp.lang.CSProcess-"><code><TT>removeProcess</TT></code></a> or
 <a href="../../jcsp/lang/Sequence.html#removeAllProcesses--"><code><TT>removeAllProcesses</TT></code></a> method.
 If a call to <TT>removeProcess</TT> or <TT>removeAllProcesses</TT>
 is made while the <TT>run</TT> method is executing, the process will
 not be removed from the network until the next time <TT>run</TT> is
 invoked.
 </P>
 <H2>Example - Matrix Multiply (in Sequence and in Parallel)</H2>
 <P>
 The following example illustrates a simple transformation of sequential code
 into parallel code.  On a shared-memory parallel machine (e.g. a Symmetric
 Multi-Processor) and depending on the overheads for starting up and shutting
 down the concurrency and the scale of the problem to which it is applied,
 the parallel code will terminate earlier than its sequential equivalent.

 <H3><A NAME="multiply">Sequential Implementation</H3>
 The example is simple matrix multiplication.  The standard implementation
 consists of three nested <TT>for</TT>-loops, the innermost of which computes
 the <I>dot-product</I> of a row (of the first matrix) against a column (of
 the second) to produce one element of the result matrix.  It is expressed
 here as a static method, which would belong to some larger collection of
 static methods providing a general matrix handling class:
 <PRE>
   public static void multiply (final double[][] X,
                                final double[][] Y,
                                final double[][] Z) {
 <I></I>
     ...  check (X[0].length == Y.length)
     ...  check (X.length == Z.length)
     ...  check (Y[0].length == Z[0].length)
 <I></I>
     for (int i = 0; i < X.length; i++) {
       final double[] Xi = X[i];
       final double[] Zi = Z[i];
       for (int j = 0; j < Y[0].length; j++) {
         double sum = 0.0d;
         for (int k = 0; k < Y.length; k++) {
           sum += Xi[k]*Y[k][j];
         }
         Zi[j] = sum;
       }
     }
 <I></I>
   }
 </PRE>
 The method computes the matrix multiplication of <TT>X</TT> by <TT>Y</TT>,
 leaving the result in <TT>Z</TT>.
 The (hidden) checks ensure that the supplied arrays have compatible
 dimensions for multiplication, throwing
 a <code><TT>java.lang.RuntimeException</TT></code>
 if they are not.
 The <I>abbreviations</I> <TT>Xi</TT> and <TT>Zi</TT> are not strictly
 necessary, but for those brought up in an <B>occam</B> world are automatic
 good practice - the <TT>Xi[k]</TT> reference
 in the O(n<sup><font size="-2">3</font></sup>)-innermost loop saves
 an array index computation and check.

 <H3><A NAME="parMultiply">Parallel Implementation</H3>
 The two outer <TT>for</TT>-loops of <A HREF="#multiply"><TT>multiply</TT></A>
 set up the particular row and column
 pairs for the <I>dot-product</I> computed by the innermost loop.
 Unnecessarilly, they impose an ordering in which those <I>dot-products</I>
 are computed.  Each <I>dot-product</I> computes one element of the result
 matrix and is independent of its sibling <I>dot-products</I>.
 The sequential constraint may, therefore, be removed and all elements
 of the result matrix may be computed in parallel.
 <P>
 If this were <B>occam</B>, all we would need to do is replace the two outer
 <TT>for</TT>-loops with <TT>par</TT>-loops.  Since this is Java, we have
 to jump through some slightly higher syntactic hoops.  First, we need
 to transform the body of the <TT>for</TT>-loop into a <I>process</I> and
 use the loop to assign each one to consecutive elements of a <I>process</I>
 array.  Then, we simply run the array in parallel:
 <PRE>
   public static void parMultiply (final double[][] X,
                                   final double[][] Y,
                                   final double[][] Z) {
 <I></I>
     ...  check array dimensions are compatible
 <I></I>
     final CSProcess[] rowProcess = new CSProcess[X.length];
 <I></I>
     for (int i = 0; i < X.length; i++) {
       final int ii = i;
       rowProcess[ii] = new CSProcess () {
         public void run () {
           final double[] Xi = X[ii];
           final double[] Zi = Z[ii];
           final double[][] YY = Y;
           for (int j = 0; j < YY[0].length; j++) {
             double sum = 0.0d;
             for (int k = 0; k < YY.length; k++) {
               sum += Xi[k]*YY[k][j];
             }
             Zi[j] = sum;
           }
         }
       };
     }
 <I></I>
     new Parallel (rowProcess).run ();
 <I></I>
   }
 </PRE>
 [<I>Note:</I> anonymous inner classes, as in the above code, may only access
 <I>global</I> variables that are qualified as <TT>final</TT> - hence, the need
 to freeze the loop control index, <TT>i</TT>, as <TT>ii</TT>.
 The abreviation <TT>YY</TT>, of <TT>Y</TT>, is so that access to that matrix
 is via a variable <I>local</I> to the process.  The <I>global</I> <TT>Y</TT>
 could have been used, but at the cost of needless run-time overhead.]

 <H3>Back to Sequential Implementation</H3>
 Having expressed this algorithm in terms of <I>processes</I>, we come to the
 motivation for this example.  To run a collection of processes, we must decide
 whether to run them is <I>parallel</I> or <I>sequence</I>.  JCSP makes either
 decision equally easy to implement.  The above coding ran them in parallel.
 To revert to running them is sequence, all we need do is change the last line
 of executable code to:
 <PRE>
     new Sequence (rowProcess).run ();
 </PRE>
 It would probably be good to name this new method <TT>seqMultiply</TT> (instead
 or <TT>parMultiply</TT>!).
 Of course, it has the same behaviour as the original sequential <TT>multiply</TT> and
 suffers only slightly increased overheads - negligible for matrices above a modest size.

 <H3><TT>Sequence</TT> versus <TT>Parallel</TT></H3>
 Beware that it is only in certain circumstances that <TT>Sequence</TT> and <TT>Parallel</TT>
 can be interchanged without upsetting the semantics of the system.  The processes under
 their control must be finite (i.e. they must all terminate), they must engage in
 no synchronisations (e.g. channel communication) either between themselves or with
 other processes and they must obey CREW-parallel usage rules (i.e. if one process
 updates some data, no other process may look at it).  These are fulfilled by
 the <TT>rowProcess</TT> array, each of whose processes computes a separate row
 (<TT>Zi</TT>) of the target result matrix (<TT>Z</TT>).

 <H3>Exercise</H3>
 The above <TT>parMultiply</TT> has transformed only the outermost
 <TT>for</TT>-loop of <TT>multiply</TT> into a <TT>par</TT>-loop.  Current SMPs
 do not scale well above 4 or 8 processors, so we do not need very large matrices
 for this code to demonstrate high parallel efficiencies.  Future architectures,
 however, may offer much higher levels of physical concurrency that efficiently
 support much finer granularities of process.  For those machines and as an interesting
 exercise, parallelise the middle <TT>for</TT>-loop.  To exploit even finer levels
 of parallel granularity, parallelise the innermost <TT>for</TT>-loop so that it
 computes its <I>dot-product</I> in O(log(n)) time - rather than the O(n) time of
 the sequential code.

 <H3>Two Important Modifications on <TT>parMultiply</TT></H3>
 The first time it is <TT>run</TT>, the JCSP <a href="../../jcsp/lang/Parallel.html" title="class in jcsp.lang"><code>Parallel</code></a> process
 creates a new <code>Thread</code> for all but one of its component processes,
 running its last component in the thread invoking the <TT>run</TT>.
 When (and if) all those component processes terminate, the <TT>Parallel</TT>
 <TT>run</TT> terminates but leaves the newly created threads parked for later use.
 Subsequent <TT>run</TT>s of the <TT>Parallel</TT> process resuse those parked threads.
 So the overhead of thread creation occurs only for the <I>first</I> run.
 <P>
 In <A HREF="#parMultiply"><TT>parMultiply</TT></A>, however, the <TT>Parallel</TT>
 process is anonymous and local to the method and so can never be used again.
 Worse, the threads it created and parked are left parked - wasting space for
 the remainder of the program.  Repeated invocations of <TT>parMultiply</TT>,
 therefore, will leak memory.
 <P>
 There are two ways to fix this.  The first is to accept that the <TT>Parallel</TT>
 process created by <TT>parMultiply</TT> remains local to it (and, hence, un-reusable)
 and, explicitly, to unpark and terminate its unwanted threads.  This can be done by
 invoking <a href="../../jcsp/lang/Parallel.html#releaseAllThreads--"><code><TT>releaseAllThreads</TT></code></a> on
 the <TT>Parallel</TT> after it has been <TT>run</TT> - the memory associated with
 those threads will be released.  A temporary name for the process needs to be
 assigned and the last executable line of <A HREF="#parMultiply"><TT>parMultiply</TT></A>
 becomes the three lines:
 <PRE>
     final Parallel par = new Parallel (rowProcess);
     par.run ();
     par.releaseAllThreads ();
 </PRE>

 The second way to improve things is to save the <TT>Parallel</TT> process for later
 runs.  There is no easy way for doing this local to the class to which
 <TT>parMultiply</TT> belongs.  <TT>parMultiply</TT> is <TT>static</TT> and may be
 invoked with matrix parameters of different dimensions.  So, a <TT>static</TT> data
 structure would need to be set up and consulted each time <TT>parMultiply</TT> was
 invoked to see if a suitable <TT>Parallel</TT> process had already been saved.
 <P>
 Much better is to give the <I>user</I> of <TT>parMultiply</TT> the responsibilty of
 looking after - and directly using, reusing and (if necessary) terminating the threads
 in - the <TT>Parallel</TT> process.  So, we change the method into something that
 <I>manufactures</I> a process that does parallel matrix multiplication.
 That multiplication will be specific to the three matrices given as parameters
 (i.e. it performs <TT>Z = X*Y</TT> <I>on those matrices only</I>):
 <PRE>
   public static Parallel makeParMultiply (final double[][] X,
                                           final double[][] Y,
                                           final double[][] Z) {
 <I></I>
     ...  check array dimensions are compatible                     // as before
 <I></I>
     final CSProcess[] rowProcess = new CSProcess[X.length];        // as before
 <I></I>
     for (int i = 0; i < X.length; i++) {                           // as before
       final int ii = i;                                            // as before
       rowProcess[ii] = new CSProcess () {                          // as before
         public void run () {                                       // as before
           final double[] Xi = X[ii];                               // as before
           final double[] Zi = Z[ii];                               // as before
           final double[][] YY = Y;                                 // as before
           for (int j = 0; j < YY[0].length; j++) {                 // as before
             double sum = 0.0d;                                     // as before
             for (int k = 0; k < YY.length; k++) {                  // as before
               sum += Xi[k]*YY[k][j];                               // as before
             }                                                      // as before
             Zi[j] = sum;                                           // as before
           }                                                        // as before
         }                                                          // as before
       };                                                           // as before
     }                                                              // as before
 <I></I>
     return new Parallel (rowProcess);
 <I></I>
   }
 </PRE>
 The invoker of <TT>makeParMultiply</TT> gets back a parallel process that can be
 invoked as often as needed and incurs a thread creation overhead only on its first use.
 The data for the matrix parameters may be freely changed between invocations - each
 invocation will work on whatever data is present at the time.  All the user must
 remember is that the manufactured parallel process is good only for working with
 the matrix objects specified originally to <TT>makeParMultiply</TT> as its parameters.
 For example, if <TT>Matrix</TT> is the class to which <TT>makeParMultiply</TT> belongs:
 <PRE>
     final Parallel par = Matrix.makeParMultiply (X, Y, Z);
 <I></I>
     while (...) {
       ...  set up matrices X and Y
       par.run ();
       ...  do something with the result matrix Z
     }
 <I></I>
     par.releaseAllThreads ();
 </PRE></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../jcsp/lang/CSProcess.html" title="interface in jcsp.lang"><code>CSProcess</code></a>, 
<a href="../../jcsp/lang/Parallel.html" title="class in jcsp.lang"><code>Parallel</code></a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../jcsp/lang/Sequence.html#Sequence--">Sequence</a></span>()</code>
<div class="block">Construct a new <TT>Sequence</TT> object initially without any processes.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../jcsp/lang/Sequence.html#Sequence-jcsp.lang.CSProcess:A-">Sequence</a></span>(<a href="../../jcsp/lang/CSProcess.html" title="interface in jcsp.lang">CSProcess</a>[]&nbsp;processes)</code>
<div class="block">Construct a new <TT>Sequence</TT> object with the processes specified.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/Sequence.html#addProcess-jcsp.lang.CSProcess-">addProcess</a></span>(<a href="../../jcsp/lang/CSProcess.html" title="interface in jcsp.lang">CSProcess</a>&nbsp;process)</code>
<div class="block">Add the process to the <TT>Sequence</TT> object.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/Sequence.html#addProcess-jcsp.lang.CSProcess:A-">addProcess</a></span>(<a href="../../jcsp/lang/CSProcess.html" title="interface in jcsp.lang">CSProcess</a>[]&nbsp;newProcesses)</code>
<div class="block">Add the array of processes to the <TT>Sequence</TT> object.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/Sequence.html#removeAllProcesses--">removeAllProcesses</a></span>()</code>
<div class="block">Remove all processes from the <TT>Sequence</TT> object.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/Sequence.html#removeProcess-jcsp.lang.CSProcess-">removeProcess</a></span>(<a href="../../jcsp/lang/CSProcess.html" title="interface in jcsp.lang">CSProcess</a>&nbsp;process)</code>
<div class="block">Remove a process from the <TT>Sequence</TT> object.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/Sequence.html#run--">run</a></span>()</code>
<div class="block">Run the sequential composition of the processes registered with this
 <TT>Sequence</TT> object.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Sequence--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Sequence</h4>
<pre>public&nbsp;Sequence()</pre>
<div class="block">Construct a new <TT>Sequence</TT> object initially without any processes.</div>
</li>
</ul>
<a name="Sequence-jcsp.lang.CSProcess:A-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Sequence</h4>
<pre>public&nbsp;Sequence(<a href="../../jcsp/lang/CSProcess.html" title="interface in jcsp.lang">CSProcess</a>[]&nbsp;processes)</pre>
<div class="block">Construct a new <TT>Sequence</TT> object with the processes specified.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>processes</code> - the processes to be executed in sequence</dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="addProcess-jcsp.lang.CSProcess-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addProcess</h4>
<pre>public&nbsp;void&nbsp;addProcess(<a href="../../jcsp/lang/CSProcess.html" title="interface in jcsp.lang">CSProcess</a>&nbsp;process)</pre>
<div class="block">Add the process to the <TT>Sequence</TT> object.
 The extended network
 will be executed the next time run() is invoked.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>process</code> - The CSProcess to be added</dd>
</dl>
</li>
</ul>
<a name="addProcess-jcsp.lang.CSProcess:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addProcess</h4>
<pre>public&nbsp;void&nbsp;addProcess(<a href="../../jcsp/lang/CSProcess.html" title="interface in jcsp.lang">CSProcess</a>[]&nbsp;newProcesses)</pre>
<div class="block">Add the array of processes to the <TT>Sequence</TT> object.
 The extended network
 will be executed the next time run() is invoked.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>newProcesses</code> - the processes to be added</dd>
</dl>
</li>
</ul>
<a name="removeProcess-jcsp.lang.CSProcess-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeProcess</h4>
<pre>public&nbsp;void&nbsp;removeProcess(<a href="../../jcsp/lang/CSProcess.html" title="interface in jcsp.lang">CSProcess</a>&nbsp;process)</pre>
<div class="block">Remove a process from the <TT>Sequence</TT> object. The cut-down network
 will be executed the next time run() is invoked.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>process</code> - the process to be removed</dd>
</dl>
</li>
</ul>
<a name="removeAllProcesses--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeAllProcesses</h4>
<pre>public&nbsp;void&nbsp;removeAllProcesses()</pre>
<div class="block">Remove all processes from the <TT>Sequence</TT> object.  The cut-down network
 will not be executed until the next time <TT>run()</TT> is invoked.</div>
</li>
</ul>
<a name="run--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>run</h4>
<pre>public&nbsp;void&nbsp;run()</pre>
<div class="block">Run the sequential composition of the processes registered with this
 <TT>Sequence</TT> object.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../jcsp/lang/CSProcess.html#run--">run</a></code>&nbsp;in interface&nbsp;<code><a href="../../jcsp/lang/CSProcess.html" title="interface in jcsp.lang">CSProcess</a></code></dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../jcsp/lang/RejectableOne2OneChannel.html" title="class in jcsp.lang"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../jcsp/lang/SharedAltingConnectionClient.html" title="class in jcsp.lang"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?jcsp/lang/Sequence.html" target="_top">Frames</a></li>
<li><a href="Sequence.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
