<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_162) on Wed Apr 25 09:57:43 BST 2018 -->
<title>AltingBarrier (jcsp alpha-1.1.2 API)</title>
<meta name="date" content="2018-04-25">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="AltingBarrier (jcsp alpha-1.1.2 API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":9,"i3":9,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../jcsp/lang/AlternativeError.html" title="class in jcsp.lang"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../jcsp/lang/AltingBarrierError.html" title="class in jcsp.lang"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?jcsp/lang/AltingBarrier.html" target="_top">Frames</a></li>
<li><a href="AltingBarrier.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">jcsp.lang</div>
<h2 title="Class AltingBarrier" class="title">Class AltingBarrier</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li><a href="../../jcsp/lang/Guard.html" title="class in jcsp.lang">jcsp.lang.Guard</a></li>
<li>
<ul class="inheritance">
<li>jcsp.lang.AltingBarrier</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="typeNameLabel">AltingBarrier</span>
extends <a href="../../jcsp/lang/Guard.html" title="class in jcsp.lang">Guard</a></pre>
<div class="block">This is the <i>front-end</i> for a <i>barrier</i> that can be used as
 a <a href="../../jcsp/lang/Guard.html" title="class in jcsp.lang"><code>Guard</code></a> in an <a href="../../jcsp/lang/Alternative.html" title="class in jcsp.lang"><code>Alternative</code></a>.
 <p>
 <H2>Description</H2>
 An <i>alting</i> barrier is represented by a family of <code>AltingBarrier</code>
 <i>front-ends</i>.  Each <i>process</i> using the barrier must do so via its
 own <i>front-end</i>.  A new <i>alting</i> barrier is created by the static
 <a href="../../jcsp/lang/AltingBarrier.html#create-int-"><code>create</code></a> method, which returns an array of <i>front-ends</i>.
 If new processes need to be enrolled, further <i>front-ends</i> may be made
 from an existing one (see <a href="../../jcsp/lang/AltingBarrier.html#expand-int-"><code>expand</code></a> and
 <a href="../../jcsp/lang/AltingBarrier.html#contract-jcsp.lang.AltingBarrier:A-"><code>contract</code></a>).
 A process may temporarilly <a href="../../jcsp/lang/AltingBarrier.html#resign--"><code>resign</code></a> from a barrier and, later,
 re-<a href="../../jcsp/lang/AltingBarrier.html#enroll--"><code>enroll</code></a>.
 <p>
 To use this barrier, a process simply includes its given <code>AltingBarrier</code>
 <i>front-end</i> in a <a href="../../jcsp/lang/Guard.html" title="class in jcsp.lang"><code>Guard</code></a> array associated with an <a href="../../jcsp/lang/Alternative.html" title="class in jcsp.lang"><code>Alternative</code></a>.
 Its index will be selected if and only if all parties (processes) to the barrier
 similarly select it (using their own <i>front-ends</i>).
 </p>
 <p>
 If a process wishes to commit to this barrier (i.e. not offer it as a choice
 in an <a href="../../jcsp/lang/Alternative.html" title="class in jcsp.lang"><code>Alternative</code></a>), it may <a href="../../jcsp/lang/AltingBarrier.html#sync--"><code>sync</code></a> on it.
 However, if all parties only do this, a <i>non-alting</i> <a href="../../jcsp/lang/Barrier.html" title="class in jcsp.lang"><code>Barrier</code></a>
 would be more efficient.
 A further shortcut (over using an <a href="../../jcsp/lang/Alternative.html" title="class in jcsp.lang"><code>Alternative</code></a>) is provided
 to <a href="../../jcsp/lang/AltingBarrier.html#poll-long-"><code>poll</code></a> this barrier for completion.
 </p>
 <p>
 An <code>AltingBarrier</code> <i>front-end</i> may only be used by one process
 at a time (and this is checked at run-time).
 A process may communicate a non-resigned <i>front-end</i> to another process;
 but the receiving process must <a href="../../jcsp/lang/AltingBarrier.html#mark--"><code>mark</code></a> it before using it and,
 of course, the sending process must not continue to use it.
 If a process terminates holding a <i>front-end</i>, it may be recycled
 for use by another process via <a href="../../jcsp/lang/AltingBarrier.html#reset--"><code>reset</code></a>.
 </p>
 <H3>Priorities</H3>
 These do not <i>-- and cannot --</i> apply to selection between barriers.
 The <a href="../../jcsp/lang/Alternative.html#priSelect--"><code>priSelect()</code></a> method works locally for
 the process making the offer.
 If this were allowed, one process might offer barrier <code>x</code> with higher
 priority than barrier <code>y</code> ... and another process might offer them
 with its priorities the other way around.
 In which case, it would be impossible to resolve a choice in favour of
 <code>x</code> or <code>y</code> in any way that satisfied the conflicting
 priorities of both processes.
 </p>
 <p>
 However, the <a href="../../jcsp/lang/Alternative.html#priSelect--"><code>priSelect()</code></a> method <i>is</i>
 allowed for choices including barrier guards.  It honours the respective
 priorities defined between <i>non-barrier</i> guards ... and those
 between a <i>barrier</i> guard and <i>non-barrier</i> guards (which
 guarantees, for example, immediate response to a timeout from ever-active
 barriers).  Relative priorities between <i>barrier</i> guards are inoperative.
 </p>
 <H3>Misuse</H3>
 The implementation defends against misuse, throwing an <a href="../../jcsp/lang/AltingBarrierError.html" title="class in jcsp.lang"><code>AltingBarrierError</code></a>
 error when riled.  See the documentation for <a href="../../jcsp/lang/AltingBarrierError.html" title="class in jcsp.lang"><code>AltingBarrierError</code></a> for
 circumstances.
 </p>
 <H2>Example 0 <i>(a single alting barrier)</i></H2>
 Here is a simple gadget with two modes of operation, switched by a <i>click</i>
 event (operated externally by a button in the application below).
 Initially, it is in <i>individual</i> mode -- represented here by incrementing
 a number and outputting it (as a <code>String</code> to change the label on
 its controlling button) as often as it can.
 Its other mode is <i>group</i>, in which it can only work if all associated
 gadgets are also in this mode.  Group work consists of a single decrement
 and output of the number (to its button's label).
 It performs group work as often as the group will allow (i.e. until it, or
 one of its partner gadgets, is clicked back to <i>individual</i> mode).
 <PRE>
 import jcsp.lang.*;
 
 public class AltingBarrierGadget0 implements CSProcess {
 
   private final AltingChannelInput click;
   private final AltingBarrier group;
   private final ChannelOutput configure;
 
   public AltingBarrierGadget0 (
     AltingChannelInput click, AltingBarrier group, ChannelOutput configure
   ) {
     this.click = click;
     this.group = group;
     this.configure = configure;
   }
 
   public void run () {
 
     final Alternative clickGroup =
       new Alternative (new Guard[] {click, group});
 
     final int CLICK = 0, GROUP = 1;
 
     int n = 0;
     configure.write (String.valueOf (n));
 
     while (true) {
 
       configure.write (Color.green)                <i>// pretty</i>
 
       while (!click.pending ()) {                  <i>// individual work mode</i>
         n++;                                       <i>// work on our own</i>
         configure.write (String.valueOf (n));      <i>// work on our own</i>
       }
       click.read ();                               <i>// must consume the click</i>
 
       configure.write (Color.red);                 <i>// pretty</i>
       
       boolean group = true;                        <i>// group work mode</i>
       while (group) {
         switch (clickGroup.priSelect ()) {         <i>// offer to work with the group</i>
           case CLICK:
             click.read ();                         <i>// must consume the click</i>
             group = false;                         <i>// back to individual work mode</i>
           break;
           case GROUP:
             n--;                                   <i>// work with the group</i>
             configure.write (String.valueOf (n));  <i>// work with the group</i>
           break;
         }
       }
       
     }
 
   }
 
 }
 </PRE>
 Here is code for a system of buttons and gadgets, synchronised by
 an <i>alting barrier</i>.  Note that this <i>single</i> event needs
 an array of <code>AltingBarrier</code> <i>front-ends</i> to operate --
 one for each gadget:
 <PRE>
 import jcsp.lang.*;
 import jcsp.plugNplay.*;
 
 public class AltingBarrierGadget0Demo0 {
 
   public static void main (String[] argv) {
 
     final int nUnits = 8;

     <i>// make the buttons</i>
 
     final One2OneChannel[] event = Channel.one2oneArray (nUnits);
     
     final One2OneChannel[] configure = Channel.one2oneArray (nUnits);
 
     final boolean horizontal = true;
 
     final FramedButtonArray buttons =
       new FramedButtonArray (
         "AltingBarrier: Gadget 0, Demo 0", nUnits, 120, nUnits*100,
          horizontal, configure, event
       );
 
     <i>// construct an array of front-ends to a single alting barrier</i>
 
     final AltingBarrier[] group = AltingBarrier.create (nUnits);
 
     <i>// make the gadgets</i>
 
     final AltingBarrierGadget0[] gadgets = new AltingBarrierGadget0[nUnits]; 
     for (int i = 0; i < gadgets.length; i++) {
       gadgets[i] = new AltingBarrierGadget0 (event[i], group[i], configure[i]);
     }
 
     <i>// run everything</i>
 
     new Parallel (
       new CSProcess[] {
         buttons, new Parallel (gadgets)
       }
     ).run ();
 
   }
 
 }
 </PRE>
 The very simple <i>"group"</i> work in the above example consists of actions
 performed independently by each gadget (decrementing the number on its
 button's label).  The (alting) barrier synchronisation ensures that
 these decrements keep in step with each other.
 <p>
 A more interesting gadget would work with other gadgets for <i>group</i> work
 that really did require them all to be engaged.
 For example, they resume operation of a machine that would be dangerous if
 some gadgets (perhaps those responsible for safety aspects) were doing
 their <i>individual</i> work.
 </p>
 <H2>Example 1 <i>(lots of alting barriers)</i></H2>
 This example derives from a pathological challenge to the management of choice
 between multiway synchronisations raised by <i>Michael Goldsmith (Formal
 Systems Europe)</i>.
 There are three processes (<code>P</code>, <code>Q</code> and <code>R</code>)
 and theee events (<code>a</code>, <code>b</code> and <code>c</code>).
 <code>P</code> offers events <code>a</code> and <code>b</code>;
 <code>Q</code> offers events <code>b</code> and <code>c</code>;
 and <code>R</code> offers events <code>c</code> and <code>a</code>.
 If <code>P</code> and <code>Q</code> synchronise on <code>b</code>,
 they do something (possibly together) then start again.
 Similarly if <code>Q</code> and <code>R</code> synchronise on <code>c</code>
 or if <code>R</code> and <code>P</code> synchronise on <code>a</code>.
 In CSP, the expression is trivial:
 <PRE>
  P = ((a -> P0); P) [] ((b -> P1); P), and where c is not in the alphabet of P
  Q = ((b -> Q0); Q) [] ((c -> Q1); Q), and where a is not in the alphabet of Q
  R = ((c -> R0); R) [] ((a -> R1); R), and where b is not in the alphabet of R

  SYSTEM = (P || Q || R) \ {a, b, c}
 </PRE>
 To impact their environment (and avoid <i>divergence</i>), the sub-processes
 <code>P0</code>, <code>P1</code>, <code>Q0</code>, <code>Q1</code>,
 <code>R0</code> and <code>R1</code> will engage in external events
 (i.e. not just <code>a</code>, <code>b</code> or <code>c</code>).
 Additionally, <code>P1</code> and <code>Q0</code>
 (triggered by <code>b</code>) may engage in other hidden events,
 not given in the above.
 The same for <code>Q1</code> and <code>R0</code>
 (triggered by <code>c</code>) and for <code>R1</code> and <code>P0</code>
 (triggered by <code>a</code>).
 </p>
 <p>
 In our version, there are <code>N</code> processes and events arranged (logically)
 around a circle.
 Each process is either <i>off</i> or on <i>standby</i>, switching between
 these states on random timeouts.
 Each process is also attached to a personal button that it uses
 to indicate its state.
 When <i>off</i>, it colours its button black; when on <i>standby</i>,
 light gray.
 </p>
 <p>
 When on <i>standby</i>, each process offers <code>(span+1)</code> events:
 a timeout, the event with it on the circle and the next <code>(span-1)</code>
 events going (say) clockwise.
 It the timeout occurs, it switches to its <i>off</i> state.
 If one of the events (<code>AltingBarrier</code>) occurs, it must have
 occured for a consecutive block of <code>span</code> processes (including
 this one ... somewhere) around the circle.
 This group now go into a <i>playing</i> state.
 </p>
 <p>
 Not mentioned before is a <i>rail track</i>, made of channels, running round
 the circle.
 When playing, the process furthest uptrack choses a colour and sends this to
 its partners down the track (to which the mulitway synchronisation ensures
 this group has exclusive access).
 Each process in the playing group then flashes its button with that colour
 a fixed (parametrised) number of times.
 The rate of flashing is coordinated by the <code>AltingBarrier</code>
 multiway synchronisation event common to the group --
 the furthest uptrack process only keeping time for this.
 After playing, the process switches to its <i>off</i> state.
 </p>
 <p>
 [Note: the above <code>SYSTEM</code> has <code>N</code> equal to
 <code>3</code>, <code>span</code> equal to <code>2</code>, no <i>off</i>
 state and no timeout on <i>standby</i>.
 The channels used to flash the buttons are the external events mentioned
 and the <i>rail track</i> channels are the hidden extras.]
 </p>
 <p>
 Here is the code for these processes.
 As usual, the constructor just saves all parameters:
 <PRE>
 import jcsp.lang.*;
 import jcsp.awt.*;
 
 import java.awt.Color;
 import java.util.Random;
 
 public class AltingBarrierGadget1 implements CSProcess {
 
   private final AltingBarrier[] barrier;
   private final AltingChannelInput in, click;
   private final ChannelOutput out, configure;
   private final Color offColour, standbyColour;
   private final int offInterval, standbyInterval;
   private final int playInterval, flashInterval;
 
   public AltingBarrierGadget1 (
     AltingBarrier[] barrier,
     AltingChannelInput in, ChannelOutput out,
     AltingChannelInput click, ChannelOutput configure,
     Color offColour, Color standbyColour,
     int offInterval, int standbyInterval,
     int playInterval, int flashInterval
   ) {
     this.barrier = barrier;
     this.in = in;  this.out = out;
     this.click = click;  this.configure = configure;
     this.offColour = offColour;  this.standbyColour = standbyColour;
     this.offInterval = offInterval;  this.standbyInterval = standbyInterval;
     this.playInterval = playInterval;  this.flashInterval = flashInterval;
   }
 </PRE>
 The <code>barrier</code> array gives this <i>gadget</i> access to
 the multiway events shared with adjacent siblings.
 The <code>in</code> and <code>out</code> channel ends are part of the
 <i>rail track</i> this gadget uses later (when <i>playing</i>).
 The <code>click</code> and <code>configure</code> channels
 attach this gadget to its button.
 The <code>click</code> channel is never used by this gadget -- it's included
 for completeness should anyone wish to enhance its behaviour.
 The other parameters are just data. 
 </p>
 <p>
 The <code>run()</code> method controls switching between <i>off</i>,
 <i>standby</i> and <i>playing</i> states.
 The latter is the choice between all the multiway syncs (and the timeout).
 It is handled by a <i>fair select</i> on the <a href="../../jcsp/lang/Alternative.html" title="class in jcsp.lang"><code>Alternative</code></a>,
 constructed just once (before loop entry):
 <PRE>
   public void run () {
  
     CSTimer tim = new CSTimer ();
 
     final Random random = new Random ();
 
     final Guard[] standbyGuard = new Guard[barrier.length + 1];
     for (int i = 0; i < barrier.length; i++) {
       standbyGuard[i] = barrier[i];
     }
     standbyGuard[barrier.length] = tim;
     final int TIMEOUT = barrier.length;
     Alternative standbyAlt = new Alternative (standbyGuard);
 
     configure.write (Boolean.FALSE);               <i>// disable mouse clicks</i>
                                                    <i>// (not used by this gadget)</i>
     while (true) {
 
       configure.write (offColour);
       tim.sleep (random.nextInt (offInterval));
 
       configure.write (standbyColour);
       tim.setAlarm (tim.read () + random.nextInt (standbyInterval));
 
       int choice = standbyAlt.fairSelect ();       <i>// magic synchronisation</i>
 
       if (choice != TIMEOUT) {
         play (choice, random, tim);
       }
       
     }
  
   }
 </PRE>
 Here is the <i>playing</i> code.
 Initially, a colour is chosen and passed down the playing group's section
 of <i>rail track</i>, to which it has exclusive access.
 The flashing group is coordinated through the group's common event,
 with just one of them keeping time.
 <PRE>
   private void play (int choice, Random random, CSTimer tim) {
     
     final boolean RIGHTMOST = (choice == 0);
     final boolean LEFTMOST = (choice == (barrier.length - 1));
 
     Color colour = null;
     if (RIGHTMOST) {
       colour = new Color (random.nextInt ());
     } else {
       colour = (Color) in.read ();
     }
     Color bright = colour.brighter ();
 
     if (!LEFTMOST) out.write (colour);             <i>// pass it on</i>
 
     final AltingBarrier focus = barrier[choice];
 
     final int count = playInterval/flashInterval;
 
     long timeout = tim.read () + flashInterval;
     
     boolean bright = true;
 
     for (int i = 0; i < count; i++) {
       configure.write (bright ? brighter : colour);
       bright = !bright;
       if (RIGHTMOST) {
         tim.after (timeout);
         timeout += flashInterval;
       }
       focus.sync ();
     }
 
   }
 
 }
 </PRE>
 Here is code setting up a <i>"circle"</i> of these gadgets, buttons and
 alting barriers.
 The buttons are laid out in a row, so that the rightmost button is actually
 on the <i>"left"</i> of the leftmost button.
 Care needs to be taken to distribute the <code>span</code> <i>front-ends</i>
 for each <code>AltingBarrier</code> to the correct gadgets --
 see the <i>re-arrangement</i> below:
 <PRE>
 import jcsp.lang.*;
 import jcsp.util.*;
 import jcsp.plugNplay.*;
 
 import java.awt.Color;
 import java.util.Random;
 
 public class AltingBarrierGadget1Demo0 {
 
   public static void main (String[] argv) {
 
     final int nUnits = 30, span = 6;
     
     final int offInterval = 800, standbyInterval = 1000;    <i>// milliseconds</i>
     
     final int playInterval = 10000, flashInterval = 500;    <i>// milliseconds</i>
 
     final Color offColour = Color.black, standbyColour = Color.lightGray;
 
     <i>// make the buttons</i>
 
     final One2OneChannel[] click =
       Channel.one2oneArray (nUnits, new OverWriteOldestBuffer (1));
 
     final One2OneChannel[] configure = Channel.one2oneArray (nUnits);
 
     final boolean horizontal = true;
 
     final FramedButtonArray buttons =
       new FramedButtonArray (
         "AltingBarrier: Gadget 1, Demo 0", nUnits, 100, nUnits*50,
          horizontal, configure, click
       );
 
     <i>// construct nUnits barriers, each with span front-ends ...</i>
 
     AltingBarrier[][] ab = new AltingBarrier[nUnits][];
     for (int i = 0; i < nUnits; i++) {
       ab[i] = AltingBarrier.create (span);
     }
 
     <i>// re-arrange front-ends, ready for distribution to processes ...</i>
 
     AltingBarrier[][]barrier = new AltingBarrier[nUnits][span];
     for (int i = 0; i < nUnits; i++) {
       for (int j = 0; j < span; j++) {
         barrier[i][j] = ab[(i + j) % nUnits][j];
       }
     }
 
     <i>// make the track and the gadgets</i>
 
     One2OneChannel[] track = Channel.one2oneArray (nUnits);
 
     AltingBarrierGadget1[] gadgets = new AltingBarrierGadget1[nUnits];
     for (int i = 0; i < nUnits; i++) {
       gadgets[i] =
         new AltingBarrierGadget1 (
           barrier[i],
           track[(i + 1)%nUnits], track[i],
           click[i], configure[i],
           offColour, standbyColour,
           offInterval, standbyInterval,
           playInterval, flashInterval
         );
     }
 
     <i>// run everything</i>
 
     new Parallel (
       new CSProcess[] {
         buttons, new Parallel (gadgets)
       }
     ).run ();
 
   }
 
 }
 </PRE>
 For fun, here is another application program for the same gadget.
 It allows a much larger system to be built, laying out the <i>circle</i>
 of buttons in a grid, row by row.
 The rightmost button on each row is to the <i>left</i> of the leftmost
 button on the next row down.
 The <i>next row down</i> from the bottom row is the top row.
 The buttons and its <code>click</code> and <code>configure</code> channels
 are now two dimensional structures.
 The barriers, gadgets and rail track are still one dimensional.
 Only code differences from the above are shown:
 <PRE>
 import jcsp.lang.*;
 import jcsp.util.*;
 import jcsp.plugNplay.*;
 
 import java.awt.Color;
 import java.util.Random;
 
 public class AltingBarrierGadget1Demo1 {
 
   public static void main (String[] argv) {
 
     final int width = 30, depth = 20;
     final int nUnits = width*depth;
     
     <i>...  the other system parameters (final ints and Colors)</i>
     
     final One2OneChannel[][] click = new One2OneChannel[depth][];
     for (int i = 0; i < depth; i++) {
       click[i] = Channel.one2oneArray (width, new OverWriteOldestBuffer (1));
     }
     
     final One2OneChannel[][] configure = new One2OneChannel[depth][];
     for (int i = 0; i < depth; i++) {
       configure[i] = Channel.one2oneArray (width);
     }
 
     final FramedButtonGrid buttons =
       new FramedButtonGrid (
         "AltingBarrier: Gadget 1, Demo 1", depth, width,
         20 + (depth*50), width*50, configure, click
       );
 
     <i>...  construct nUnits barriers and the track exactly as before</i>
 
     AltingBarrierGadget1[] gadgets = new AltingBarrierGadget1[nUnits];
     for (int i = 0; i < nUnits; i++) {
       gadgets[i] =
         new AltingBarrierGadget1 (
           barrier[i],
           track[(i + 1)%nUnits], track[i],
           click[i/width][i%width],
           configure[i/width][i%width],
           offColour, standbyColour,
           offInterval, standbyInterval,
           playInterval, flashInterval
         );
     }
 
     <i>...  build and run the buttons and gadgets in parallel</i>
 
   }
 
 }
 </PRE>
 
 <H3>Other Examples</H3>
 The <code>alting-barriers</code> directory in <code>jcsp-demos</code>
 contains other gadgets in a similar vein.
 
 <H4><code>AltingBarrierGadget2</code></H4>
 These are similar to <code>AltingBarrierGadget1</code>, but sit on
 a <i>2-way</i> circular railtrack offering to synchronise in the same
 <code>span</code>-groups.
 Their difference is the game they play when synchronised:
 <i>pass-the-parcel</i> up and down their section of track, with
 the parcel's (rapid) progress indicated by writing on the button labels.
 These gadgets also enable their buttons when playing and finish their game
 when any one, or more, of their buttons is clicked -- or they get bored and
 timeout.
 
 <H4><code>AltingBarrierGadget3</code></H4>
 Along with their attached buttons, these form a two dimensional structure
 covering the surface of a <i>torus</i>.
 The gadgets on the <i>top</i> row are adjacent to the gadgets on
 the <i>bottom</i> row.
 The gadgets on the <i>left</i> column are adjacent to the gadgets on
 the <i>right</i> column.
 The demonstration program, <code>AltingBarrierGadget3Demo0</code>,
 asks the user to choose between various shapes and sizes for
 the synchronisation groups (<i>pluses</i>, <i>crosses</i> and
 <i>circles</i>) -- but all groups have the same shape and size.
 </p>
 <p>
 Creation and distribution of the barriers is not done by the demonstration
 program but, more simply, by the gadgets themselves.
 Each <code>AltingBarrierGadget3</code> belongs to many synchronisation
 groups, but has <i>lead</i> responsibility for one.
 It services the input end of a single channel and is given the (shared)
 output ends of the service channels to the other gadgets in the group
 it is leading.
 <i>[Note: the giver of those output ends is the demonstration program.]</i>
 It creates the alting barrier (and some other things -- see below) for
 its lead group.
 Distribution is by <i>I/O-PAR</i> exchange over their service channels as
 the gadgets initialise.
 Each gadget sends the things it made to the gadgets in the group it is
 leading and receives the same from the leaders of its other synchronisation
 groups.
 This is the only use they make of these channels.  
 </p>
 <p>
 A synchronised group plays a simple counting game until one of its buttons
 is clicked or the countdown reaches zero.
 Termination of the game is, and has to be, simultaneous.
 This is managed by a <i>shared</i> termination flag, safely operated
 through <i>phased barrier synchronisation</i> (which lets any process
 in the group set it in an <i>even phase</i>, with all processes acting
 on it in the <i>odd</i> phases).
 Shared label and colour variables (for the group's buttons) are operated
 similarly.
 The shared variables are distributed (as fields of a shared object) by
 the leader gadget, along with the group's <i>alting</i> barrier front-ends,
 during initialisation.
 </p>
 <p>
 The group's <code>AltingBarrier</code> is used to separate the phases.
 <i>Alting</i> capability on this barrier enables rapid response to
 <i>any</i> button click on the group to end the game.
 The lead gadget controls timing: it <i>alts</i> between a countdown timeout,
 its button click and a cancel message from the rest of the group (should
 any of their buttons be clicked) -- following any of these with the barrier
 sync, scheduling the next phase.
 The other gadgets <i>alt</i> between their button click and the barrier:
 response to a click being the (timeout) cancel message to the leader then
 wait for the barrier; response to the barrier being the next phase.
 </p>
 <p>
 The <code>Any2One</code> cancel channel is a mulitplexing relay from
 the non-lead buttons to the leader gadget.
 It is constructed by the lead gadget and distributed to its team alongside
 the shared variables.
 The cancel channel must be <i>overwriting buffered</i>
 to avoid deadlock -- the same as the click channels from buttons.
 The cancel channel must be cleared at the start of each game -- same as
 the click channels.
 </p>
 <p>
 <A NAME="user-game"><!-- --></A>
 <b><i>USER GAME</i></b>: run the demo program on a 30x20 grid (expand to
 full screen), with circle shapes (say), a radius of 3, off and standBy
 intervals of 1000 (millisecs), play interval of 10000 (millisecs) and
 a count interfavl of 200 (millisecs).
 Your challenge is to zap all the coloured shapes away before any of their
 counts reach zero and the end of the world happens, <i>:)</i>.
 How long can you survive?!!
 </p>
 
 <H4><code>AltingBarrierGadget4</code></H4>
 These are the same as the previous (<code>AltingBarrierGadget3</code>)
 gadgets, except that they do not assume that all the synchronisation groups
 to which they belong have the same shape or size.
 While they do know the size of the group they lead (from the length of
 the channel of output ends they are given), that is all they know.
 In particular, they do not know how many items (barriers etc.) to expect
 from the leaders of their other groups in the opening exchange.
 </p>
 <p>
 This is solved by giving each gadget a global barrier on which their
 parallel outputting processes synchronise when they finish their
 distribution.
 After this synchronisation, <i>all</i> exchanges must have finished and
 they can tell their gadgets to proceed.
 </p>
 <p>
 The demonstration program for these gadgets just asks for a size for
 synchronisation groups and allocates (lead) shapes randomly.
 It could randomise the sizes as well, but the smaller patterns would
 always emerge dominant in the synchronisations achieved (simply because
 they require fewer gadgets to be simultaneously on <i>standby</i> --
 i.e. offering mode) and the consequent games.
 </p>
 <p>
 <b><i>USER GAME</i></b>: same as <a href="#user-game">before</a>,
 except with a span (rather than radius) of 3.
 </p>
 
 <H4><code>AltingBarrierGadget5</code></H4>
 These are the same as <code>AltingBarrierGadget4</code>, except for
 the technique used to signal the end of the initial exchange of information
 amongst the synchronisation groups.
 They use a global <i>alting</i> barrier on which both the outputting
 and inputting partners in the exchange offer to synchronise -- the former
 when finished outputting and the latter as an alternative to inputting.
 This is, perhaps, more elegant than the <i>conventional</i> barrier and channel
 used by the <code>AltingBarrierGadget4</code> gadgets and exercises
 the <a href="../../jcsp/lang/AltingBarrier.html#expand--"><code>expand()</code></a> and <a href="../../jcsp/lang/AltingBarrier.html#contract--"><code>contract()</code></a> methods.
 </p>
 <p>
 <b><i>USER GAME</i></b>: same as <a href="#user-game">before</a>,
 except with a span (rather than radius) of 3.
 </p>
 
 <H4><code>AltingBarrierGadget6</code></H4>
 The unbuffered service channels used by <code>AltingBarrierGadget3</code>,
 <code>AltingBarrierGadget4</code> and <code>AltingBarrierGadget5</code>
 (in the opening <i>I/O-PAR</i> exchange of information amongst each
 playing group) force the leaders to synchronise with each of their
 team members.
 This is no problem for <code>AltingBarrierGadget3</code>, since all groups
 have the same size and it receives as many messages as it sends; knowing
 how many messages it is sending, it knows how large its reception arrays
 should be.
 This is not the case for <code>AltingBarrierGadget4</code> and
 <code>AltingBarrierGadget5</code>, which must first receive into
 <i>collection</i> objects that can expand to any size.
 </p>
 <p>
 <code>AltingBarrierGadget6</code> performs an <i>asynchronous</i> opening
 exchange of information, using the collection objects directly to buffer
 the communication messages and no channels.
 Further, no internal parallelism is needed for this exchange: the gadgets
 first add all their messages to the collections held by the rest of their
 team; then, they synchronise on the global barrier (a <i>non-alting</i>
 one, the same as used by <code>AltingBarrierGadget4</code>s); finally,
 they extract the information sent by the leaders of the other teams to
 which they belong.
 As before, the barrier synchronisation is crucial for the correctness of
 this exchange, ensuring that all messages are in place before they are
 gathered.
 </p>
 <p>
 <b><i>USER GAME</i></b>: same as <a href="#user-game">before</a>,
 except with a span (rather than radius) of 3.
 </p>
 <p></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../jcsp/lang/Barrier.html" title="class in jcsp.lang"><code>Barrier</code></a>, 
<a href="../../jcsp/lang/Alternative.html" title="class in jcsp.lang"><code><p></code></a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/AltingBarrier.html#contract--">contract</a></span>()</code>
<div class="block">This contracts by one the number of processes enrolled in this <i>alting</i>
 barrier.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/AltingBarrier.html#contract-jcsp.lang.AltingBarrier:A-">contract</a></span>(<a href="../../jcsp/lang/AltingBarrier.html" title="class in jcsp.lang">AltingBarrier</a>[]&nbsp;ab)</code>
<div class="block">This contracts the number of processes enrolled in this <i>alting</i> barrier.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>static <a href="../../jcsp/lang/AltingBarrier.html" title="class in jcsp.lang">AltingBarrier</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/AltingBarrier.html#create--">create</a></span>()</code>
<div class="block">This creates a new <i>alting</i> barrier with an (initial) enrollment
 count of <code>1</code>.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>static <a href="../../jcsp/lang/AltingBarrier.html" title="class in jcsp.lang">AltingBarrier</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/AltingBarrier.html#create-int-">create</a></span>(int&nbsp;n)</code>
<div class="block">This creates a new <i>alting</i> barrier with an (initial) enrollment
 count of <code>n</code>.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/AltingBarrier.html#enroll--">enroll</a></span>()</code>
<div class="block">A process may enroll only if it is resigned.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code><a href="../../jcsp/lang/AltingBarrier.html" title="class in jcsp.lang">AltingBarrier</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/AltingBarrier.html#expand--">expand</a></span>()</code>
<div class="block">This expands by one the number of processes enrolled in this <i>alting</i>
 barrier.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code><a href="../../jcsp/lang/AltingBarrier.html" title="class in jcsp.lang">AltingBarrier</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/AltingBarrier.html#expand-int-">expand</a></span>(int&nbsp;n)</code>
<div class="block">This expands the number of processes enrolled in this <i>alting</i> barrier.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/AltingBarrier.html#mark--">mark</a></span>()</code>
<div class="block">A process may hand its barrier front-end over to another process,
 but the receiving process must invoke this method before using it.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/AltingBarrier.html#poll-long-">poll</a></span>(long&nbsp;offerTime)</code>
<div class="block">This is a simple way to <i>poll</i> for synchonisation on an
 <a href="../../jcsp/lang/AltingBarrier.html" title="class in jcsp.lang"><code>AltingBarrier</code></a> without having to set up an <a href="../../jcsp/lang/Alternative.html" title="class in jcsp.lang"><code>Alternative</code></a>.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/AltingBarrier.html#reset--">reset</a></span>()</code>
<div class="block">This resets a <i>front-end</i> for reuse.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/AltingBarrier.html#resign--">resign</a></span>()</code>
<div class="block">A process may resign only if it is enrolled.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/AltingBarrier.html#sync--">sync</a></span>()</code>
<div class="block">This is a simple way to perform a <i>committed</i> synchonisation on an
 <a href="../../jcsp/lang/AltingBarrier.html" title="class in jcsp.lang"><code>AltingBarrier</code></a> without having to set up an <a href="../../jcsp/lang/Alternative.html" title="class in jcsp.lang"><code>Alternative</code></a>.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.jcsp.lang.Guard">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;jcsp.lang.<a href="../../jcsp/lang/Guard.html" title="class in jcsp.lang">Guard</a></h3>
<code><a href="../../jcsp/lang/Guard.html#schedule-jcsp.lang.Alternative-">schedule</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="create-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>create</h4>
<pre>public static&nbsp;<a href="../../jcsp/lang/AltingBarrier.html" title="class in jcsp.lang">AltingBarrier</a>[]&nbsp;create(int&nbsp;n)</pre>
<div class="block">This creates a new <i>alting</i> barrier with an (initial) enrollment
 count of <code>n</code>.
 It provides an array of <code>n</code> <i>front-end</i>s to this barrier.
 It is the invoker's responsibility to install one of these (by constructor
 or <code>set</code> method) in each process that will be synchronising on
 the barrier, <i>before</i> firing up those processes.
 <p>
 <i>Note:</i> each process must use a different <i>front-end</i> to
 the barrier.  Usually, a process retains an <code>AltingBarrier</code>
 <i>front-end</i> throughout its lifetime -- however, see <a href="../../jcsp/lang/AltingBarrier.html#mark--"><code>mark</code></a>.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>n</code> - the number of processes enrolled (initially) on this barrier.
 <p></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an array of <code>n</code> <i>front-end</i>s to this barrier.
 <p></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if <code>n</code> <= <code>0</code>.</dd>
</dl>
</li>
</ul>
<a name="create--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>create</h4>
<pre>public static&nbsp;<a href="../../jcsp/lang/AltingBarrier.html" title="class in jcsp.lang">AltingBarrier</a>&nbsp;create()</pre>
<div class="block">This creates a new <i>alting</i> barrier with an (initial) enrollment
 count of <code>1</code>.
 It provides a single <i>front-end</i> to the barrier, from which others may
 be generated (see <a href="../../jcsp/lang/AltingBarrier.html#expand--"><code>expand()</code></a>) -- usually <i>one-at-a-time</i>
 to feed processes individually <i>forked</i> (by a <a href="../../jcsp/lang/ProcessManager.html" title="class in jcsp.lang"><code>ProcessManager</code></a>).
 It is the invoker's responsibility to install each one (by constructor
 or <code>set</code> method) in the process that will be synchronising on
 the barrier, <i>before</i> firing up that process.
 Usually, a process retains an <code>AltingBarrier</code> <i>front-end</i>
 throughout its lifetime -- however, see <a href="../../jcsp/lang/AltingBarrier.html#mark--"><code>mark</code></a>.
 <p>
 <i>Note:</i> if a known number of processes needing the barrier are to be run
 (e.g. by a <a href="../../jcsp/lang/Parallel.html" title="class in jcsp.lang"><code>Parallel</code></a>), creating the barrier with an array of
 <i>front-end</i>s using <a href="../../jcsp/lang/AltingBarrier.html#create-int-"><code>create(n)</code></a> would be more convenient.
 <p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a single <i>front-end</i> for this barrier.</dd>
</dl>
</li>
</ul>
<a name="expand-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>expand</h4>
<pre>public&nbsp;<a href="../../jcsp/lang/AltingBarrier.html" title="class in jcsp.lang">AltingBarrier</a>[]&nbsp;expand(int&nbsp;n)</pre>
<div class="block">This expands the number of processes enrolled in this <i>alting</i> barrier.
 <p>
 Use it when an enrolled process is about to go <a href="../../jcsp/lang/Parallel.html" title="class in jcsp.lang"><code>Parallel</code></a> itself and
 some/all of those sub-processes also need to be enrolled.
 It returns an array new <i>front-end</i>s for this barrier.
 It is the invoker's responsibility to pass these on to those sub-processes.
 </p>
 <p>
 Note that if there are <code>x</code> sub-processes to be enrolled, this method
 must be invoked with an argument of <code>(x - 1)</code>.
 Pass the <i>returned</i> <code>AltingBarrier</code>s to <i>any</i> <code>(x - 1)</code>
 of those sub-processes.
 Pass <i>this</i> <code>AltingBarrier</code> to the last one.
 </p>
 <p>
 Before using its given <i>front-end</i> to this barrier, each sub-process
 must <a href="../../jcsp/lang/AltingBarrier.html#mark--"><code>mark</code></a> it to take ownership.
 <i>[Actually, only the sub-process given the original front-end (which
 may be running in a different thread) really has to do this.]</i>
 </p>
 <p>
 Following termination of the <a href="../../jcsp/lang/Parallel.html" title="class in jcsp.lang"><code>Parallel</code></a>, the original process must
 take back ownership of its original <code>AltingBarrier</code> <i>(loaned to one
 of the sub-processes, which may have been running on a different thread)</i>
 by <a href="../../jcsp/lang/AltingBarrier.html#mark--"><code>mark</code></a>ing it again.
 </p>
 <p>
 Also following termination of the <a href="../../jcsp/lang/Parallel.html" title="class in jcsp.lang"><code>Parallel</code></a>, the original process
 must contract the number of processes enrolled on the barrier.
 To do this, it must have retained the <i>front-end</i> array returned by
 this method and pass it to <a href="../../jcsp/lang/AltingBarrier.html#contract-jcsp.lang.AltingBarrier:A-"><code>contract</code></a>.
 </p>
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>n</code> - the number of processes to be added to this barrier.
 <p></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an array of new <i>front-end</i>s for this barrier.
 <p></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if <code>n</code> <= <code>0</code>.
 <p></dd>
<dd><code><a href="../../jcsp/lang/AltingBarrierError.html" title="class in jcsp.lang">AltingBarrierError</a></code> - if currently resigned or not owner of this
   <i>front-end</i>.</dd>
</dl>
</li>
</ul>
<a name="expand--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>expand</h4>
<pre>public&nbsp;<a href="../../jcsp/lang/AltingBarrier.html" title="class in jcsp.lang">AltingBarrier</a>&nbsp;expand()</pre>
<div class="block">This expands by one the number of processes enrolled in this <i>alting</i>
 barrier.
 <p>
 Use it when an enrolled process is about to <i>fork</i> a new process
 (using <a href="../../jcsp/lang/ProcessManager.html" title="class in jcsp.lang"><code>ProcessManager</code></a>) that also needs to be enrolled.
 It returns an new <i>front-end</i> for this barrier.
 It is the invoker's responsibility to pass it to the new process.
 </p>
 <p>
 Before terminating, the <i>forked</i> process should
 <a href="../../jcsp/lang/AltingBarrier.html#contract--"><code>contract</code></a> (by one) the number of processes
 enrolled in this barrier.
 Otherwise, no further synchronisations on this barrier would be able
 to complete.
 </p>
 <p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a new <i>front-end</i> for this barrier.
 <p></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../../jcsp/lang/AltingBarrierError.html" title="class in jcsp.lang">AltingBarrierError</a></code> - if currently resigned or not owner of this
   <i>front-end</i>.</dd>
</dl>
</li>
</ul>
<a name="contract-jcsp.lang.AltingBarrier:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>contract</h4>
<pre>public&nbsp;void&nbsp;contract(<a href="../../jcsp/lang/AltingBarrier.html" title="class in jcsp.lang">AltingBarrier</a>[]&nbsp;ab)</pre>
<div class="block">This contracts the number of processes enrolled in this <i>alting</i> barrier.
 The given <i>front-end</i>s are discarded.
 <p>
 Use it following termination of a <a href="../../jcsp/lang/Parallel.html" title="class in jcsp.lang"><code>Parallel</code></a>, some/all of whose
 sub-processes were enrolled by being given <i>front-end</i>s
 returned by <a href="../../jcsp/lang/AltingBarrier.html#expand-int-"><code>expand</code></a>.
 See the documentation for <a href="../../jcsp/lang/AltingBarrier.html#expand-int-"><code>expand</code></a>.
 </p>
 <p>
 <i>Warning:</i> only the process that went <a href="../../jcsp/lang/Parallel.html" title="class in jcsp.lang"><code>Parallel</code></a> should invoke
 this method -- never one of the sub-processes.
 </p>
 <p>
 <i>Warning:</i> never invoke this method whilst processes using
 its argument's <i>front-end</i>s are running.
 </p>
 <p>
 <i>Warning:</i> do not attempt to reuse any of the argument elements afterwards
 -- they <i>front-end</i> nothing.
 </p>
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>ab</code> - the <i>front-ends</i> being discarded from this barrier.
   This array must be unaltered from one previously delivered by
   an <a href="../../jcsp/lang/AltingBarrier.html#expand-int-"><code>expand</code></a>.
 <p></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if <code>ab</code> is <code>null</code> or zero length.
 <p></dd>
<dd><code><a href="../../jcsp/lang/AltingBarrierError.html" title="class in jcsp.lang">AltingBarrierError</a></code> - if the given array is <i>not</i> one previously
   delivered by an <a href="../../jcsp/lang/AltingBarrier.html#expand-int-"><code>expand(n)</code></a>, or the invoking process is
   currently resigned or not the owner of this <i>front-end</i>.</dd>
</dl>
</li>
</ul>
<a name="contract--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>contract</h4>
<pre>public&nbsp;void&nbsp;contract()</pre>
<div class="block">This contracts by one the number of processes enrolled in this <i>alting</i>
 barrier.
 This <i>front-end</i> cannot not be used subsequently.
 <p>
 This method should be used on individually created <i>front-end</i>s
 (see <a href="../../jcsp/lang/AltingBarrier.html#expand--"><code>expand()</code></a>) when, and only when, the process holding
 it is about to terminate.
 Normally, that process would have been <i>forked</i> by the process
 creating this barrier.
 </p>
 <p>
 <i>Warning:</i> do not try to use this <i>front-end</i> following invocation
 of this method -- it no longer fronts anything.
 </p>
 <p></div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../../jcsp/lang/AltingBarrierError.html" title="class in jcsp.lang">AltingBarrierError</a></code> - if currently resigned or not the owner of
   this <i>front-end</i>.</dd>
</dl>
</li>
</ul>
<a name="resign--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resign</h4>
<pre>public&nbsp;void&nbsp;resign()</pre>
<div class="block">A process may resign only if it is enrolled.
 A resigned process may not offer to synchronise on this barrier
 (until a subsequent <a href="../../jcsp/lang/AltingBarrier.html#enroll--"><code>enroll</code></a>).
 Other processes can complete the barrier (represented by this front-end)
 without participation by the resigned process.
 <p>
 Unless <i>all</i> processes synchronising on this barrier terminate in
 the same phase, it is usually appropriate for a terminating process
 to <i>resign</i> first.  Otherwise, its sibling processes will never be
 able to complete another synchronisation.
 </p>
 <p>
 <i>Note:</i> a process must not transfer its <i>front-end</i> to another
 process whilst resigned from the barrier -- see <a href="../../jcsp/lang/AltingBarrier.html#mark--"><code>mark</code></a>.
 </p>
 <p></div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../../jcsp/lang/AltingBarrierError.html" title="class in jcsp.lang">AltingBarrierError</a></code> - if currently resigned.</dd>
</dl>
</li>
</ul>
<a name="enroll--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>enroll</h4>
<pre>public&nbsp;void&nbsp;enroll()</pre>
<div class="block">A process may enroll only if it is resigned.
 A re-enrolled process may resume offering to synchronise on this barrier
 (until a subsequent <a href="../../jcsp/lang/AltingBarrier.html#resign--"><code>resign</code></a>).
 Other processes cannot complete the barrier (represented by this front-end)
 without participation by the re-enrolled process.
 <p>
 <i>Note:</i> timing re-enrollment on a barrier usually needs some care.
 If the barrier is being used for synchronising phases of execution between
 a set of processes, it is crucial that re-enrollment occurs in
 an appropriate <i>(not arbitrary)</i> phase.
 If the trigger for re-enrollment comes from another enrolled process,
 that process should be in such an appropriate phase.
 The resigned process should re-enroll and, then, acknowledge the trigger.
 The triggering process should wait for that acknowledgement.
 If the decision to re-enroll is internal (e.g. following a timeout),
 a <i>buddy</i> process, enrolled on the barrier, should be asked to provide
 that trigger when in an appropriate phase.
 The <i>buddy</i> process, perhaps specially built just for this purpose, polls
 a service channel for that question when in that phase.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../../jcsp/lang/AltingBarrierError.html" title="class in jcsp.lang">AltingBarrierError</a></code> - if currently enrolled.</dd>
</dl>
</li>
</ul>
<a name="mark--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mark</h4>
<pre>public&nbsp;void&nbsp;mark()</pre>
<div class="block">A process may hand its barrier front-end over to another process,
 but the receiving process must invoke this method before using it.
 Beware that the process that handed it over must no longer use it.
 </p>
 <p>
 <i>Note:</i> a process must not transfer its <i>front-end</i> to another
 process whilst resigned from the barrier -- see <a href="../../jcsp/lang/AltingBarrier.html#resign--"><code>resign</code></a>.
 The receiving process assumes this is the case.
 This <i>mark</i> will fail if it is not so.
 </p>
 <p>
 See <a href="../../jcsp/lang/AltingBarrier.html#expand-int-"><code>expand(n)</code></a> for an example pattern of use.
 <p></div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../../jcsp/lang/AltingBarrierError.html" title="class in jcsp.lang">AltingBarrierError</a></code> - if the front-end is resigned.</dd>
</dl>
</li>
</ul>
<a name="reset--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reset</h4>
<pre>public&nbsp;void&nbsp;reset()</pre>
<div class="block">This resets a <i>front-end</i> for reuse.
 It still fronts the same barrier.
 Following this method, this front-end is <i>enrolled</i> on the barrier
 and not <i>owned</i> by any process.
 </p>
 <p>
 <i>Warning:</i> this should only be used to recycle a <i>front-end</i>
 whose process has terminated.
 It should not be used to transfer a <i>front-end</i> between running
 processes (for which <a href="../../jcsp/lang/AltingBarrier.html#mark--"><code>mark</code></a> should be used).
 </p>
 <p>
 <i>Example</i>:
 <pre>
   AltingBarrier[] action = AltingBarrier.create (n);
 
   Parallel[] system = new Parallel[n];
   for (int i = 0; i < system.length; i++) {
     system[i] = new Something (action[i], ...);
   }
 
   while (true) {
     // invariant: all 'action' front-ends are enrolled on the barrier.
     // invariant: all 'action' front-ends are not yet <i>owned</i> by any process.
     system.run ();
     // assume: no 'system' process discards (contracts) its 'action' front-end.
     // note: some 'system' processes may have resigned their 'action' front-ends.
     // note: in the next run of 'system', its processes may be <i>different</i>
     //       from the point of view of the 'action' front-ends.
     for (int i = 0; i < action.length; i++) {
       action[i].reset ();
     }
     // deduce: loop invariant re-established.
   }
 </pre></div>
</li>
</ul>
<a name="sync--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sync</h4>
<pre>public&nbsp;void&nbsp;sync()</pre>
<div class="block">This is a simple way to perform a <i>committed</i> synchonisation on an
 <a href="../../jcsp/lang/AltingBarrier.html" title="class in jcsp.lang"><code>AltingBarrier</code></a> without having to set up an <a href="../../jcsp/lang/Alternative.html" title="class in jcsp.lang"><code>Alternative</code></a>.
 For example, if <code>group</code> is an <code>AltingBarrier</code>, then:
 <PRE>
     group.sync ();
 </PRE>
 saves first having to construct the single guarded:
 <PRE>
     Alternative groupCommit = new Alternative (new Guard[] {group});
 </PRE>
 and then:
 <PRE>
     groupCommit.select ();
 </PRE>
 If this is the only method of synchronisation performed by all parties
 to this barrier, a <i>non-alting</i> <a href="../../jcsp/lang/Barrier.html" title="class in jcsp.lang"><code>Barrier</code></a> would be more efficient.
 </p>
 <p>
 <i>Important note:</i> following a <code>select</code>, <code>priSelect</code> or
 <code>fairSelect</code> on an <a href="../../jcsp/lang/Alternative.html" title="class in jcsp.lang"><code>Alternative</code></a> that returns the index of
 an <code>AltingBarrier</code>, that barrier synchronisation has happened.
 Do not proceed to invoke this <code>sync</code> method -- unless, of course,
 you want to wait for a second synchronisation.</div>
</li>
</ul>
<a name="poll-long-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>poll</h4>
<pre>public&nbsp;boolean&nbsp;poll(long&nbsp;offerTime)</pre>
<div class="block">This is a simple way to <i>poll</i> for synchonisation on an
 <a href="../../jcsp/lang/AltingBarrier.html" title="class in jcsp.lang"><code>AltingBarrier</code></a> without having to set up an <a href="../../jcsp/lang/Alternative.html" title="class in jcsp.lang"><code>Alternative</code></a>.
 The parameter specifies how long this poll should leave its offer
 to synchronise on the table.
 If <code>true</code> is returned, the barrier has completed.
 If <code>false</code>, the barrier was unable to complete within
 the time specified (i.e. at no time were <i>all</i> parties making
 an offer).
 </p>
 <p>
 For example, if <code>group</code> is an <code>AltingBarrier</code>, then:
 <PRE>
     if (group.poll (offerTime)) {
       ...  group synchronisation achieved
     } else {
       ...  group synchronisation failed (within offerTime millisecs)
     }
 </PRE>
 is equivalent to:
 <PRE>
     groupTimer.setAlarm (groupTimer.read () + offerTime);
     if (groupPoll.priSelect () == 0) {
       ...  group synchronisation achieved
     } else {
       ...  group synchronisation failed (within offerTime millisecs)
     }
 </PRE>
 where first would have to have been constructed:
 <PRE>
     CSTimer groupTimer = new CSTimer ();
     Alternative groupPoll =
       new Alternative (new Guard[] {group, groupTimer});
 </PRE>
 <i>Note:</i> polling algorithms should generally be a last resort!
 If all parties to this barrier only use this method, synchronisation
 depends on all their poll periods coinciding.
 An <code>offerTime</code> of zero is allowed: if all other parties
 are offering, the barrier will complete -- otherwise, the poll returns
 immediately.
 However, if more than one party only ever polls like this,
 no synchronisation will ever take place.
 </p>
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>offerTime</code> - the time (in milliseconds) that this offer to synchronise
   should be left on the table.
 <p></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if and only if the barrier completes within
   time specifed.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../jcsp/lang/AlternativeError.html" title="class in jcsp.lang"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../jcsp/lang/AltingBarrierError.html" title="class in jcsp.lang"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?jcsp/lang/AltingBarrier.html" target="_top">Frames</a></li>
<li><a href="AltingBarrier.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
