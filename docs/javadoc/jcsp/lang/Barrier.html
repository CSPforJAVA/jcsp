<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_162) on Wed Apr 25 09:57:43 BST 2018 -->
<title>Barrier (jcsp alpha-1.1.2 API)</title>
<meta name="date" content="2018-04-25">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Barrier (jcsp alpha-1.1.2 API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../jcsp/lang/Any2OneConnection.html" title="interface in jcsp.lang"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../jcsp/lang/BarrierError.html" title="class in jcsp.lang"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?jcsp/lang/Barrier.html" target="_top">Frames</a></li>
<li><a href="Barrier.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">jcsp.lang</div>
<h2 title="Class Barrier" class="title">Class Barrier</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>jcsp.lang.Barrier</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd>java.io.Serializable</dd>
</dl>
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><a href="../../jcsp/net2/NetBarrier.html" title="class in jcsp.net2">NetBarrier</a></dd>
</dl>
<hr>
<br>
<pre>public class <span class="typeNameLabel">Barrier</span>
extends java.lang.Object
implements java.io.Serializable</pre>
<div class="block">This enables <I>barrier</I> synchronisation between a set of processes.
 <P>
 <A HREF="#constructor_summary">Shortcut to the Constructor and Method Summaries.</A>
 
 <H2>Description</H2>
 A channel is a CSP <I>event</I> in which only two processes (the reader and
 the writer) synchronise.  A barrier is a CSP <I>event</I> in which any number of
 processes may synchronise.  <I>Any</I> process synchronising on a barrier will be
 blocked until <I>all</I> processes associated with that barrier have synchronised.
 A process may not back off an attempted synchronisation - i.e. barriers cannot be
 used as guards in an <a href="../../jcsp/lang/Alternative.html" title="class in jcsp.lang"><code>Alternative</code></a>.
 Applications needing that capability should use an <a href="../../jcsp/lang/AltingBarrier.html" title="class in jcsp.lang"><code>AltingBarrier</code></a>.
 <P>
 A process network may contain many barriers - each being associated with a different
 subset of processes.  These subsets may overlap and change at run-time.  JCSP does not
 currently provide a checked way of associating a process with a particular barrier.
 That could be done, but would carry a syntactic and run-time overhead currently not
 thought worthwhile.  Associating a barrier with its correct set of processes is
 a design issue and it is left to the designer to ensure correct useage.
 <P>
 <I>Note:</I> this notion of barrier corresponds to the
 <A HREF="http://frmb.org/occ21-extensions-clean.html#barrier"><tt>BARRIER</tt></A>
 synchronisation primitive added to the
 <A HREF="http://www.cs.kent.ac.uk/projects/ofa/kroc/">KRoC</A>
 <A HREF="http://occam-pi.org/"><B>occam-pi</B></A> language system.
 
 <H3>Deterministic Barriers</H3>
 If the set of processes associated with a barrier remains fixed, barrier synchronisation
 introduces no <I>non-determinism</I>.  So, a parallel system made up of processes,
 barriers (with fixed barrier sets) and 1-1 channels (with no ALTing on the channels and
 an exclusive read/write access discipline for all communicated objects) is deterministic
 - its semantics are independent of scheduling.
 <P>
 For fixed barrier sets, <a href="../../jcsp/lang/Barrier.html#Barrier-int-"><code><R>construct</R></code></a> each barrier initialised
 to the number of processes to be associated with it and share it out amongst those processes.
 <P>
 For example, here is a fixed set of 10 processes synchronising on a shared barrier:
 <p><IMG SRC="doc-files\Barrier1.gif"></p>
 Here is the JCSP code for this network:
 <PRE>
 import jcsp.lang.*;
 
 public class BarrierExample1 {
 
   public static void main (String[] args) {
 
     final int nPlayers = 10;
 
     final Barrier barrier = new Barrier (nPlayers);
 
     final Player[] players = new Player[nPlayers];
     for (int i = 0; i < players.length; i++) {
       players[i] = new Player (i, nPlayers, barrier);
     }
 
     new Parallel (players).run ();
 
   }
 
 }
 </PRE>
 To synchronise on a barrier, a process just needs to invoke its <a href="../../jcsp/lang/Barrier.html#sync--"><code>sync</code></a>
 method.  For example:
 <PRE>
 import jcsp.lang.*;
 
 public class Player implements CSProcess {
 
   private final int id, nPlayers;
   private final Barrier barrier;
 
   public Player (int id, int nPlayers, Barrier barrier) {
     this.id = id;
     this.nPlayers = nPlayers;
     this.barrier = barrier;
   }
 
   public void run () {
     final CSTimer tim = new CSTimer ();
     final long second = 1000;          // JCSP timer units are milliseconds
     int busy = id + 1;
     while (true) {
       tim.sleep (busy*second);         // application specific work
       System.out.println ("Player " + id + " at the barrier ...");
       barrier.sync ();
       System.out.println ("\t\t\t... Player " + id + " over the barrier");
       busy = (nPlayers + 1) - busy;    // just to make it more interesting
     }
   }
 
 }
 </PRE>
 The <TT>sleep</TT> period above represents some work carried out by each <TT>Player</TT>.
 This work takes a different amount of time in each cycle and varies from player to player.
 At the end of each piece of work, each player waits for all its colleagues before continuing
 its next cycle.
 
 <H3><A NAME="ND-barrier">Non-Deterministic Barriers</H3>
 A process may choose at any time to <a href="../../jcsp/lang/Barrier.html#enroll--"><code>enroll</code></a> or <a href="../../jcsp/lang/Barrier.html#resign--"><code>resign</code></a> from
 any barrier it can see.  It should not, of course, <TT>enroll</TT> on a barrier with which
 it is already associated - nor <TT>resign</TT> from a barrier with which it isn't!  Because
 these operations are internal choices of individual processes and because they have an impact on
 the synchronisation properties of their environment, the resulting system is non-deterministic.
 <A NAME="Worker-TimeKeeper">
 <p><IMG SRC="doc-files\Barrier2.gif"></p>
 In the above example, <TT>Worker</TT> processes cycle between <I>working</I> and
 <I>resting</I> states, making their own decisions about when to switch.
 When <I>working</I>, they enroll in a barrier shared with a <TT>TimeKeeper</TT> process -
 when <I>resting</I>, they resign from this barrier.
 Whilst <I>working</I> and after they have enrolled, they execute a sequence of
 <I>work units</I> triggered by synchronisations on the barrier.
 <P>
 The <TT>TimeKeeper</TT> synchronises on the barrier at a regular rate (once per second)
 and, thus, coordinates the activities of all <I>working</I> <TT>Worker</TT>s.
 A <I>work unit</I> can only start at the beginning of one of the <TT>TimeKeeper</TT>'s
 time slots and each <TT>Worker</TT> can only perform one <I>work unit</I> per time slot.
 Should any <I>work unit</I> overrun a time slot, subsequent units (for all <TT>Worker</TT>s)
 will have a late start.
 However, the system is stable - so long as there is some slack in the system
 (i.e. units do not <I>generally</I> overrun), the original schedule will be recovered.
 <P>
 Here is the code for the complete system.
 The <TT>barrier</TT> is initialised to just <TT>1</TT>, since only the <TT>TimeKeeper</TT>
 is permanently associated with it.
 The <TT>barrier</TT> is passed to all <TT>Worker</TT>s as well as to the <TT>TimeKeeper</TT>:
 <PRE>
 import jcsp.lang.*;
 
 public class BarrierExample2 {
 
   public static void main (String[] args) {
 
     final int nWorkers = 10;
     final int rogue = 5;
 
     final int second = 1000;
     // JCSP timer units are milliseconds
     final int tick = 1*second;
     final int maxWork = tick;
     // raise this to allow workers to overrun
 
     final long seed = new CSTimer ().read ();
 
     final Barrier barrier = new Barrier (1);
 
     final TimeKeeper timeKeeper = new TimeKeeper (tick, barrier);
 
     final Worker[] workers = new Worker[nWorkers];
     for (int i = 0; i < workers.length; i++) {
       workers[i] = new Worker (i, i + seed, maxWork, i == rogue, barrier);
     }
 
     new Parallel (
       new CSProcess[] {
         timeKeeper,
         new Parallel (workers)
       }
     ).run ();
   }
 }
 </PRE>
 As well as the <TT>barrier</TT>, each <TT>Worker</TT> is given its <TT>id</TT>, a (unique)
 <TT>seed</TT> for its random number generator, its maximum work unit time and whether it is
 a <TT>rogue</TT>.  A rogue worker deliberately overruns its last unit of work for each
 working session to test out the stability of the system:
 <PRE>
 import jcsp.lang.*;
 import java.util.*;
 
 public class Worker implements CSProcess {
 
   private final int id;
   private final long seed;
   private final int maxWork;
   private final boolean rogue;
   private final Barrier barrier;
 
   public Worker (int id, long seed, int maxWork,
                  boolean rogue, Barrier barrier) {
     this.id = id;
     this.seed = seed;
     this.maxWork = maxWork;
     this.rogue = rogue;
     this.barrier = barrier;
   }
 
   public void run () {
 
     final Random random = new Random (seed);
     // each process gets a different seed
 
     final CSTimer tim = new CSTimer ();
     final int second = 1000;
     // JCSP timer units are milliseconds
 
     final int minRest = 3*second;
     final int maxRest = (id + 10)*second;
     final int nWorkUnits = id + 1;
 
     final String starting = "\tWorker " + id
                             + " starting ...";
     final String  working = "\t\t\t  ... Worker " + id
                             + " working ...";
     final String  resting = "\t\t\t\t\t       ... Worker "
                             + id + " resting ...";
 
     while (true) {
       barrier.enroll ();
       System.out.println (starting);
       for (int i = 0; i < nWorkUnits; i++) {
         barrier.sync ();
         System.out.println (working);
         tim.sleep (random.nextInt (maxWork));
         //these lines represent one unit of work
       }
       if (rogue) tim.sleep (maxWork);
       // try to throw the timekeeper
       barrier.resign ();
       System.out.println (resting);
       tim.sleep (minRest + random.nextInt (maxRest));
     }
   }
 
 }
 </PRE>
 Note that the <a href="../../jcsp/lang/Barrier.html#resign--"><code>resign</code></a> method also performs a (non-blocking) synchronisation
 on the barrier as well as the resignation.  This is crucial since, if the resigner were
 the last process associated with a barrier not to have invoked a <a href="../../jcsp/lang/Barrier.html#sync--"><code>sync</code></a>,
 its resignation must <I>complete</I> the barrier (as though it had invoked a <TT>sync</TT>)
 and release all the remaining associated processes.
 <P>
 The <TT>TimeKeeper</TT> is passed its <TT>tick</TT> interval and the <TT>Barrier</TT>.
 It is pre-enrolled with the <TT>Barrier</TT> and remains permanently associated:
 <PRE>
 import jcsp.lang.*;
 
 public class TimeKeeper implements CSProcess {
 
   private final long interval;
   private final Barrier barrier;
 
   public TimeKeeper (long interval, Barrier barrier) {
     this.interval = interval;
     this.barrier = barrier;
   }
 
   public void run () {
 
     final CSTimer tim = new CSTimer ();
     long timeout = tim.read () + interval;
 
     while (true) {
       tim.after (timeout);
       barrier.sync ();
       System.out.println ("[" + (tim.read () - timeout) + "]");
       timeout += interval;
     }
   }
 
 }
 </PRE>
 The print statement from the <TT>TimeKeeper</TT> gives an upper bound on how far each
 timeslot strays from its schedule.  JCSP <a href="../../jcsp/lang/CSTimer.html" title="class in jcsp.lang"><code>CSTimer</code></a>s are currently implemented
 on top of standard Java APIs (<TT>Thread.sleep</TT> and <TT>Object.wait</TT>).
 Depending on the underlying JVM, this should stay close to zero (milliseconds) - except
 when the rogue <TT>Worker</TT> deliberately overruns a work unit.
 Other events may also disturb the schedule - e.g. a <TT>Ctl-S</TT>/<TT>Ctl-Q</TT> from
 the user to <I>pause</I>/<I>resume</I> output or some transient fit of activity from
 the operating system.  Some JVMs also return early from some timeouts - i.e. the timeslot
 starts early, which gives rise to an occasional negative report from the <TT>TimeKeeper</TT>.
 <P>
 Bear also in mind that the <TT>TimeKeeper</TT>'s print statement has to compete with
 the print statements from all working <TT>Worker</TT>s.  All are scheduled to execute
 at the start of each timeslot and may be arbitrarilly interleaved.
 This may be confusing when interpreting the output from the system.
 <P>
 To clarify what's happening, we can arrange for the <TT>TimeKeeper</TT>'s message
 to be printed first for each timeslot, <I>before</I> any from the <TT>Worker</TT>s.
 To do this, we need to stall those <TT>Worker</TT>s temporarilly until we know that
 the <TT>TimeKeeper</TT> has reported.  A simple way to do that is to double up on
 the barrier synchronisation.  For the <TT>Worker</TT>, modify its <I>working</I> loop:
 <PRE>
   for (int i = 0; i < nWorkUnits; i++) {
     barrier.sync ();                     // wait for everyone
     barrier.sync ();                     // wait for the Timekeeper to report
     System.out.println (working);
     tim.sleep (random.nextInt (maxWork));
   }
 </PRE>
 For the <TT>TimeKeeper</TT>, modify its <TT>run</TT> loop:
 <PRE>
   while (true) {
     tim.after (timeout);
     barrier.sync ();                     // wait for everyone
     System.out.println ("[" + (tim.read () - timeout) + "]");
     barrier.sync ();                     // let the Workers get going
     timeout += interval;
   }
 </PRE>
 
 <H3>Overheads</H3>
 Free use of additional synchronisations to gain special control (such as in the above)
 depends on the overheads being not so great as to render that control pointless.
 <P>
 Going back to the <A HREF="#Worker-TimeKeeper">original example</A>, the entire barrier
 synchronisation could be discarded by dropping the <TT>TimeKeeper</TT> and making each
 <TT>Worker</TT> responsible for its own time schedule.
 However, setting <TT>n</TT> timeouts (where each setting has <TT>O(n)</TT> overheads)
 needs to be compared against setting <TT>1</TT> timeout (by the <TT>TimeKeeper</TT>)
 together with a <TT>(n+1)</TT>-way barrier synchronisation.
 <P>
 For the current implementation, the <a href="../../jcsp/lang/Barrier.html#enroll--"><code>enroll</code></a> and <a href="../../jcsp/lang/Barrier.html#resign--"><code>resign</code></a>
 operations - together with <I>most</I> of the <a href="../../jcsp/lang/Barrier.html#sync--"><code>sync</code></a>s - have unit time
 costs.  The <I>final</I> <TT>sync</TT>, which releases all the other (<TT>n</TT>)
 processes blocked on the barrier, takes <TT>O(n)</TT> time.  The unit time costs
 for this implementation are comparable with those of a <TT>synchronized</TT> method
 invocation followed by an <TT>Object.wait</TT>.
 <P>
 [<I>Note:</I> CSP synchronisation primitives can be implemented with much lighter
 overheads.  For example,
 the <A HREF="http://www.hensa.ac.uk/parallel/occam/projects/occam-for-all/kroc/">KRoC</A>
 <B>occam</B> equivalent to this <TT>Barrier</TT>
 (its <A HREF="http://www.hensa.ac.uk/parallel/occam/projects/occam-for-all/hlps/">EVENT</A>)
 has (sub-microsecond) unit time costs for <I>all</I> its operations, including
 the <I>final</I> <TT>sync</TT>.  Future work on JCSP may look towards this standard.]</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../jcsp/lang/AltingBarrier.html" title="class in jcsp.lang"><code>AltingBarrier</code></a>, 
<a href="../../jcsp/lang/Bucket.html" title="class in jcsp.lang"><code>Bucket</code></a>, 
<a href="../../jcsp/lang/Alternative.html" title="class in jcsp.lang"><code>Alternative</code></a>, 
<a href="../../serialized-form.html#jcsp.lang.Barrier">Serialized Form</a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../jcsp/lang/Barrier.html#Barrier--">Barrier</a></span>()</code>
<div class="block">Construct a barrier initially associated with no processes.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../jcsp/lang/Barrier.html#Barrier-int-">Barrier</a></span>(int&nbsp;nEnrolled)</code>
<div class="block">Construct a barrier (initially) associated with <TT>nEnrolled</TT> processes.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/Barrier.html#enroll--">enroll</a></span>()</code>
<div class="block">A process may enroll only if it is resigned.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/Barrier.html#reset-int-">reset</a></span>(int&nbsp;nEnrolled)</code>
<div class="block">Reset this barrier to be associated with <TT>nEnrolled</TT> processes.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/Barrier.html#resign--">resign</a></span>()</code>
<div class="block">A process may resign only if it is enrolled.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../jcsp/lang/Barrier.html#sync--">sync</a></span>()</code>
<div class="block">Synchronise the invoking process on this barrier.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Barrier--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Barrier</h4>
<pre>public&nbsp;Barrier()</pre>
<div class="block">Construct a barrier initially associated with no processes.</div>
</li>
</ul>
<a name="Barrier-int-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Barrier</h4>
<pre>public&nbsp;Barrier(int&nbsp;nEnrolled)</pre>
<div class="block">Construct a barrier (initially) associated with <TT>nEnrolled</TT> processes.
 It is the responsibility of the constructing process to pass this
 (by constructor or <tt>set</tt> method) to each process that will be
 synchronising on the barrier, <i>before</i> firing up those processes.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nEnrolled</code> - the number of processes (initially) associated with this barrier.
 <p></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if <tt>nEnrolled</tt> < <tt>0</tt>.</dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="reset-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reset</h4>
<pre>public&nbsp;void&nbsp;reset(int&nbsp;nEnrolled)</pre>
<div class="block">Reset this barrier to be associated with <TT>nEnrolled</TT> processes.
 This must only be done at a time when no processes are active on the barrier.
 It is the responsibility of the invoking process to pass this barrier
 (by constructor or <tt>set</tt> method) to each process that will be
 synchronising on the barrier, <i>before</i> firing up those processes.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>nEnrolled</code> - the number of processes reset to this barrier.
 <p></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if <tt>nEnrolled</tt> < <tt>0</tt>.</dd>
</dl>
</li>
</ul>
<a name="sync--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sync</h4>
<pre>public&nbsp;void&nbsp;sync()</pre>
<div class="block">Synchronise the invoking process on this barrier.
 <I>Any</I> process synchronising on this barrier will be blocked until <I>all</I>
 processes associated with the barrier have synchronised (or resigned).</div>
</li>
</ul>
<a name="enroll--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>enroll</h4>
<pre>public&nbsp;void&nbsp;enroll()</pre>
<div class="block">A process may enroll only if it is resigned.
 A re-enrolled process may resume offering to synchronise on this barrier
 (until a subsequent <a href="../../jcsp/lang/Barrier.html#resign--"><code>resign</code></a>).
 Other processes cannot complete the barrier (represented by this front-end)
 without participation by the re-enrolled process.
 <p>
 <i>Note:</i> timing re-enrollment on a barrier usually needs some care.
 If the barrier is being used for synchronising phases of execution between
 a set of processes, it is crucial that re-enrollment occurs in
 an appropriate <i>(not arbitrary)</i> phase.
 If the trigger for re-enrollment comes from another enrolled process,
 that process should be in such an appropriate phase.
 The resigned process should re-enroll and, then, acknowledge the trigger.
 The triggering process should wait for that acknowledgement.
 If the decision to re-enroll is internal (e.g. following a timeout),
 a <i>buddy</i> process, enrolled on the barrier, should be asked to provide
 that trigger when in an appropriate phase.
 The <i>buddy</i> process, perhaps specially built just for this purpose, polls
 a service channel for that question when in that phase.
 </p>
 <p>
 <i>Warning:</i> the rule in the first sentence above is
 the responsibility of the designer -- it is not checked by
 implementation.
 If not honoured, things will go wrong.</div>
</li>
</ul>
<a name="resign--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>resign</h4>
<pre>public&nbsp;void&nbsp;resign()</pre>
<div class="block">A process may resign only if it is enrolled.
 A resigned process may not offer to synchronise on this barrier
 (until a subsequent <a href="../../jcsp/lang/Barrier.html#enroll--"><code>enroll</code></a>).
 Other processes can complete the barrier (represented by this front-end)
 without participation by the resigned process.
 <p>
 Unless <i>all</i> processes synchronising on this barrier terminate in
 the same phase, it is usually appropriate for a terminating process
 to <i>resign</i> first.  Otherwise, its sibling processes will never be
 able to complete another synchronisation.
 </p>
 <p>
 <i>Warning:</i> the rules in the first two sentences above are
 the responsibility of the designer -- they are not checked by
 implementation.
 If not honoured, things will go wrong.
 </p>
 <p></div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="../../jcsp/lang/BarrierError.html" title="class in jcsp.lang">BarrierError</a></code> - if not enrolled <i>(but this is not always detected)</i>.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../jcsp/lang/Any2OneConnection.html" title="interface in jcsp.lang"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../jcsp/lang/BarrierError.html" title="class in jcsp.lang"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?jcsp/lang/Barrier.html" target="_top">Frames</a></li>
<li><a href="Barrier.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
